# Atelier PHP Pratique ‚Äì Programmation Orient√©e Objet (OOP)

## üéØ Objectif

Transformer toutes les notions OOP du document en pratique imm√©diate sous VS Code, **sans supprimer aucune id√©e** : classes/objets, propri√©t√©s/m√©thodes, `$this`, visibilit√© (public/priv√©/protected), constructeurs/destructeurs, h√©ritage, override, `static`, `final`, **interfaces (et constantes d‚Äôinterface)**, **classes abstraites**, **traits**, **m√©thodes magiques & surchargement**, **it√©ration d‚Äôobjets**, **clonage (shallow/deep)**, **classes anonymes**.  
Chaque bloc ci-dessous se copie tel quel et s‚Äôex√©cute (PHP 8+ recommand√©). Les explications sont **au-dessus** du code.

---

## 1) Classes, objets, `$this`, op√©rateur `->`

**But :** comprendre la structure d‚Äôune classe, cr√©er des objets, appeler des m√©thodes et acc√©der aux propri√©t√©s avec `->`. `$this` r√©f√©rence l‚Äô**objet appelant** dans le contexte d‚Äôinstance .

Cr√©er le fichier **01_classes_objets.php** :

```php
<?php
// Affichage d‚Äôerreurs pour pratiquer confortablement
error_reporting(E_ALL);
ini_set('display_errors', 1);

/*
  D√©finition d‚Äôune classe simple avec deux propri√©t√©s et quatre m√©thodes.
  $this->... pointe toujours sur l‚Äôinstance courante.
*/
class Book {
    // NB: on montre volontairement "var" pour rester fid√®le au contenu source
    // m√™me si 'public' est pr√©f√©rable en PHP 8.
    var $title;
    var $price;

    function setTitle($value) { $this->title = $value; }   // setter
    function getTitle()       { echo $this->title . PHP_EOL; } // getter (affiche)

    function setPrice($value) { $this->price = $value; }   // setter
    function getPrice()       { echo $this->price . PHP_EOL; } // getter (affiche)
}

// Cr√©ation de deux objets ind√©pendants (new alloue la m√©moire, objets distincts)
$b1 = new Book;
$b2 = new Book;

// Affectations via les m√©thodes d‚Äôinstance
$b1->setTitle("PHP Programming");
$b1->setPrice(450);
$b2->setTitle("PHP Fundamentals");
$b2->setPrice(275);

// Lecture via les getters (d√©monstration)
$b1->getTitle();
$b1->getPrice();
$b2->getTitle();
$b2->getPrice();
```

‚úÖ R√©sultat attendu (sortie console) :

```
PHP Programming
450
PHP Fundamentals
275
```

*(R√©f√©rence : structure Book, cr√©ation d‚Äôobjets, op√©rateur `->`, `$this` )*

---

## 2) Visibilit√© : `public`, `private`, `protected`

**But :** contr√¥ler l‚Äôacc√®s aux membres. Par d√©faut, les membres sont **publics** (dans l‚Äôancien style) ; on montre aussi `private`/`protected` et l‚Äôeffet en h√©ritage .

Cr√©er le fichier **02_visibilite.php** :

```php
<?php
error_reporting(E_ALL);
ini_set('display_errors', 1);

/*
  Exemple 1 : public (accessible partout via l‚Äôinstance).
*/
class Person {
    var $name; // public (style ancien)
    var $age;  // public

    function __construct(string $n="Ravi", int $a=28) {
        $this->name = $n;
        $this->age  = $a;
    }
    function getName() { echo "Name: $this->name" . PHP_EOL; }
    function getAge()  { echo "Age:  $this->age"  . PHP_EOL; }
}

$p = new Person();
$p->getName();
$p->getAge();
echo "Name : $p->name Age: $p->age" . PHP_EOL;

/*
  Exemple 2 : private & protected : visibilit√© restreinte.
  - private: accessible UNIQUEMENT dans la classe qui le d√©clare.
  - protected: accessible dans la classe + les classes enfants.
*/
class Base {
    private   string $secret = "TOP";
    protected string $model  = "Skoda";
    public    string $driver = "SRK";

    public function show() {
        // OK : dans la m√™me classe, on acc√®de √† private/protected/public
        echo "secret=$this->secret, model=$this->model, driver=$this->driver" . PHP_EOL;
    }
}

class Child extends Base {
    public function demo() {
        // echo $this->secret; // ‚ùå ERREUR: private => inaccessible ici
        echo "model=$this->model, driver=$this->driver" . PHP_EOL; // OK: protected/public
    }
}

$b = new Base();
$b->show();
$c = new Child();
$c->demo();
```

*(R√©f√©rences : d√©finitions & exemples de membres publics/priv√©s/prot√©g√©s )*

---

## 3) Constructeur et destructeur

**But :** initialiser et nettoyer les ressources d‚Äôun objet. Le constructeur `__construct()` est appel√© √† chaque `new`. `__destruct()` est appel√© √† la destruction .

Cr√©er le fichier **03_constructeur_destructeur.php** :

```php
<?php
error_reporting(E_ALL);
ini_set('display_errors', 1);

/*
  Initialisation via __construct(), lib√©ration via __destruct().
*/
class Connexion {
    private string $dsn;

    public function __construct(string $dsn) {
        $this->dsn = $dsn;
        echo "[INIT] DSN=$dsn" . PHP_EOL;
    }

    public function ping() { echo "[PING] $this->dsn" . PHP_EOL; }

    public function __destruct() {
        echo "[CLEANUP] Fermeture de $this->dsn" . PHP_EOL;
    }
}

$db = new Connexion("mysql:host=localhost;dbname=test");
$db->ping();
```

*(R√©f√©rence : r√¥le de `__construct()`/`__destruct()` )*

---

## 4) H√©ritage, override (red√©finition)

**But :** r√©utiliser et √©tendre le comportement d‚Äôune classe, red√©finir des m√©thodes (override) dans la classe enfant .

Cr√©er le fichier **04_heritage_override.php** :

```php
<?php
error_reporting(E_ALL);
ini_set('display_errors', 1);

class ParentClass {
    public function hello()  { echo "Hello from the parent class" . PHP_EOL; }
    public function thanks() { echo "Thank you from parent class" . PHP_EOL; }
}

// L‚Äôenfant h√©rite et PEUT red√©finir certaines m√©thodes
class ChildClass extends ParentClass {
    public function thanks() { echo "Thank you from the child class" . PHP_EOL; }
}

// D√©mo
$parent = new ParentClass();
$parent->hello();
$parent->thanks();

$child  = new ChildClass();
$child->hello();    // h√©rit√© tel quel
$child->thanks();   // version red√©finie (override)
```

‚úÖ Observations : la version enfant de `thanks()` l‚Äôemporte √† l‚Äôappel via l‚Äôobjet enfant.  
*(R√©f√©rence : exemple d‚Äôoverride & h√©ritage )*

---

## 5) `static`, `self::`, `final`

**But :** acc√©der √† un membre au niveau **classe** (sans instance), et emp√™cher une extension/surd√©finition avec `final` .

Cr√©er le fichier **05_static_final.php** :

```php
<?php
error_reporting(E_ALL);
ini_set('display_errors', 1);

/*
  Membre statique : accessible via NomDeClasse::$membre
  et depuis une m√©thode via self::$membre.
*/
class Foo {
    public static string $my_static = 'foo';
    public function staticValue() { return self::$my_static; }
}
echo Foo::$my_static . PHP_EOL;
$f = new Foo();
echo $f->staticValue() . PHP_EOL;

/*
  final : interdit d‚Äôoverride (sur m√©thode) et d‚Äôh√©ritage (sur classe).
*/
class BaseClass {
    public function test() { echo "BaseClass::test()" . PHP_EOL; }
    final public function moreTesting() { echo "BaseClass::moreTesting()" . PHP_EOL; }
}

class ChildClass extends BaseClass {
    // public function moreTesting() {} // ‚ùå Provoquerait une erreur fatale
}
(new ChildClass())->test();
(new ChildClass())->moreTesting();
```

*(R√©f√©rences : exemples `static` et `final` )*

---

## 6) Interfaces (y compris **constantes d‚Äôinterface**)

**But :** d√©finir des **contrats** de m√©thodes sans impl√©mentation ; une classe peut impl√©menter **plusieurs** interfaces ; une interface peut exposer des **constantes** partag√©es .

Cr√©er le fichier **06_interfaces.php** :

```php
<?php
error_reporting(E_ALL);
ini_set('display_errors', 1);

/* Contrat simple */
interface Mail { public function sendMail(); }

/* Impl√©mentation du contrat */
class Report implements Mail {
    public function sendMail() { echo "[Report] sending..." . PHP_EOL; }
}

/* Multiples interfaces + constantes d‚Äôinterface */
interface A { public function methodA(); }
interface B { public function methodB(); }

interface Animal {
    public const TYPE = "Mammal";     // constante d‚Äôinterface
    public function makeSound();
}

class MyClass implements A, B {
    public function methodA(){ echo "Method A from interface A" . PHP_EOL; }
    public function methodB(){ echo "Method B from interface B" . PHP_EOL; }
}

class Dog implements Animal {
    public function makeSound(){ echo "Bark!" . PHP_EOL; }
}

(new Report())->sendMail();
(new MyClass())->methodA();
(new MyClass())->methodB();
echo Dog::TYPE . PHP_EOL;
(new Dog())->makeSound();
```

*(R√©f√©rences : interface/impl√©mentation + constantes d‚Äôinterface )*

---

## 7) Classes abstraites

**But :** factoriser du code **non instanciable** (mod√®le/prototype) ; la classe enfant doit impl√©menter les m√©thodes abstraites .

Cr√©er le fichier **07_abstraites.php** :

```php
<?php
error_reporting(E_ALL);
ini_set('display_errors', 1);

/*
  Une classe abstraite ne peut pas √™tre instanci√©e.
  Les m√©thodes "abstract" doivent √™tre impl√©ment√©es par l‚Äôenfant.
*/
abstract class Shape {
    abstract public function area(): float;
    public function describe(){ echo "Je suis une forme" . PHP_EOL; }
}

class Circle extends Shape {
    public function __construct(private float $r) {}
    public function area(): float { return M_PI * $this->r * $this->r; }
}

$s = new Circle(2.0);
$s->describe();
echo "Aire = " . $s->area() . PHP_EOL;
```

*(R√©f√©rences : r√®gles & syntaxe des classes abstraites )*

---

## 8) Traits (r√©utilisation transversale de m√©thodes)

**But :** partager des m√©thodes entre classes **sans** h√©ritage multiple (que PHP ne supporte pas) .

Cr√©er le fichier **08_traits.php** :

```php
<?php
error_reporting(E_ALL);
ini_set('display_errors', 1);

/*
  Un trait regroupe des m√©thodes r√©utilisables.
*/
trait LoggerTrait {
    public function logInfo(string $msg){ echo "[INFO] $msg" . PHP_EOL; }
    public function logWarn(string $msg){ echo "[WARN] $msg" . PHP_EOL; }
}

class ServiceA {
    use LoggerTrait; // injection des m√©thodes
    public function run(){ $this->logInfo("ServiceA OK"); }
}

class ServiceB {
    use LoggerTrait;
    public function run(){ $this->logWarn("ServiceB WARN"); }
}

(new ServiceA())->run();
(new ServiceB())->run();
```

*(R√©f√©rence : d√©finition/usage d‚Äôun trait )*

---

## 9) M√©thodes magiques et ¬´ surchargement ¬ª (acc√®s dynamiques)

**But :** intercepter des acc√®s √† des propri√©t√©s **inaccessibles/inexistantes** via `__get`, `__set`, `__isset`, `__unset` ; utile pour proxys, DTO dynamiques, etc. .

Cr√©er le fichier **09_surcharge_magique.php** :

```php
<?php
error_reporting(E_ALL);
ini_set('display_errors', 1);

/*
  Interception des acc√®s propri√©t√© via __get/__set/__isset/__unset.
*/
class DynamicBag {
    private array $data = [];

    public function __set(string $name, mixed $value): void {
        echo "setting $name to $value" . PHP_EOL;
        $this->data[$name] = $value;
    }

    public function __get(string $name): mixed {
        echo "getting $name => ";
        return $this->data[$name] ?? null;
    }

    public function __isset(string $name): bool {
        return isset($this->data[$name]);
    }

    public function __unset(string $name): void {
        unset($this->data[$name]);
    }
}

$bag = new DynamicBag();
$bag->myproperty = "Hello World!";
echo $bag->myproperty . PHP_EOL;
```

*(R√©f√©rence : m√©thodes magiques de ¬´ surchargement ¬ª )*

---

## 10) It√©rer sur un objet (impl√©menter `Iterator`)

**But :** rendre une classe **it√©rable** dans `foreach` en impl√©mentant l‚Äôinterface `Iterator` (m√©thodes `rewind/current/key/next/valid`) .

Cr√©er le fichier **10_iterator.php** :

```php
<?php
error_reporting(E_ALL);
ini_set('display_errors', 1);

/*
  Impl√©mentation minimale de Iterator pour permettre foreach sur l‚Äôobjet.
*/
class Book implements Iterator {
    private array $properties = [];
    private int $position = 0;

    public function __construct(string $title, string $author, int $year) {
        $this->properties = ['title'=>$title,'author'=>$author,'year'=>$year];
    }

    public function rewind(): void { $this->position = 0; }
    public function current(): mixed { return array_values($this->properties)[$this->position]; }
    public function key(): mixed { return array_keys($this->properties)[$this->position]; }
    public function next(): void { ++$this->position; }
    public function valid(): bool { return $this->position < count($this->properties); }
}

$obj = new Book("PHP Basics","Jane Doe",2024);
foreach ($obj as $k => $v) {
    echo "$k: $v" . PHP_EOL;
}
```

*(R√©f√©rence : it√©ration et sortie attendue analogue )*

---

## 11) Clonage : copie superficielle (shallow) vs copie profonde (deep)

**But :** comprendre la diff√©rence : une **copie superficielle** partage les sous-objets ; une **copie profonde** duplique les sous-objets pour **d√©corr√©ler** original et clone .

Cr√©er le fichier **11_clone_shallow_deep.php** :

```php
<?php
error_reporting(E_ALL);
ini_set('display_errors', 1);

/*
  Exemple illustratif : Address est un sous-objet d√©tenu par Person.
*/

class Address {
    public function __construct(public string $city, public string $zip) {}
    public function set(string $city, string $zip){ $this->city=$city; $this->zip=$zip; }
}

class Person {
    public function __construct(public string $name, public Address $addr) {}

    // CLONAGE PROFOND : on red√©finit __clone pour dupliquer le sous-objet
    public function __clone() {
        $this->addr = new Address($this->addr->city, $this->addr->zip);
    }
}

// Objet original
$orig = new Person("Raja", new Address("Nanded","431601"));
echo "original: {$orig->name}, {$orig->addr->city}, {$orig->addr->zip}\n";

// Clone profond
$clone = clone $orig;

// On modifie l‚Äôoriginal apr√®s clonage
$orig->name = "Ravi";
$orig->addr->set("Mumbai","400001");

echo "after change (original): {$orig->name}, {$orig->addr->city}, {$orig->addr->zip}\n";
echo "cloned object: {$clone->name}, {$clone->addr->city}, {$clone->addr->zip}\n";
```

‚úÖ Attendu : le **clone** garde l‚Äôancienne adresse/nom (pas impact√© par les modifs).  
*(R√©f√©rences : d√©monstration deep vs shallow et sortie correspondante )*

---

## 12) Constantes de classe (visibilit√©)

**But :** illustrer l‚Äôacc√®s aux constantes `public`/`private` et les erreurs d‚Äôacc√®s direct.

Cr√©er le fichier **12_constantes_classe.php** :

```php
<?php
error_reporting(E_ALL);
ini_set('display_errors', 1);

/*
  Constantes de classe : visibilit√©s et erreurs volontaires (√† observer).
*/
class Example {
    public const PUBLIC_C = 10;
    private const SECRET_C = 20;

    public function showPrivate() {
        // OK : depuis la classe, acc√®s autoris√©
        echo "private=" . self::SECRET_C . PHP_EOL;
    }
}
echo "public=" . Example::PUBLIC_C . PHP_EOL;
// echo Example::SECRET_C; // ‚ùå Fatal error si d√©comment√© (private)
(new Example())->showPrivate();
```

*(R√©f√©rence : d√©monstration d‚Äôerreurs d‚Äôacc√®s aux constantes priv√©es )*

---

## 13) Appeler le constructeur du parent

**But :** r√©utiliser l‚Äôinitialisation du parent depuis l‚Äôenfant au lieu de tout r√©√©crire .

Cr√©er le fichier **13_parent_constructor.php** :

```php
<?php
error_reporting(E_ALL);
ini_set('display_errors', 1);

/*
  Exemple moderne : parent::__construct() pour r√©utiliser l'init du parent.
*/
class Name {
    protected string $_firstName;
    protected string $_lastName;

    public function __construct(string $first, string $last) {
        $this->_firstName = $first;
        $this->_lastName  = $last;
    }
    public function toString() { return $this->_lastName . ", " . $this->_firstName; }
}

class NameSub1 extends Name {
    protected string $_middleInitial;

    public function __construct(string $first, string $middle, string $last) {
        parent::__construct($first, $last);          // <-- appel du parent
        $this->_middleInitial = $middle;
    }
    public function toString() { return parent::toString() . " " . $this->_middleInitial; }
}

$n = new NameSub1("Ada","L","Lovelace");
echo $n->toString() . PHP_EOL;
```

*(R√©f√©rence : id√©e d‚Äôappeler le constructeur parent et red√©finir proprement )*

---

## 14) Mod√®le d‚Äôh√©ritage & extension de fonctionnalit√©

**But :** montrer un enfant qui ajoute des propri√©t√©s/m√©thodes √† un parent (ex : `ebook` √©tend `Book`) .

Cr√©er le fichier **14_extension_fonctionnalite.php** :

```php
<?php
error_reporting(E_ALL);
ini_set('display_errors', 1);

class Book {
    protected int $price;
    protected string $title;

    public function set(string $t, int $p){ $this->title=$t; $this->price=$p; }
    public function show(){ echo "Title: $this->title Price: $this->price" . PHP_EOL; }
}

class EBook extends Book {
    private string $format;
    public function setE(string $t, int $p, string $fmt){ $this->set($t,$p); $this->format=$fmt; }
    public function showE(){ $this->show(); echo "Format: $this->format" . PHP_EOL; }
}

$eb = new EBook();
$eb->setE("PHP Fundamentals", 450, "EPUB");
$eb->showE();
```

*(R√©f√©rence : exemple parent/enfant et ajout de fonctionnalit√© )*

---

## 15) Classes anonymes (PHP ‚â• 7)

**But :** cr√©er une classe **sans nom** pour un usage ponctuel .

Cr√©er le fichier **15_classes_anonymes.php** :

```php
<?php
error_reporting(E_ALL);
ini_set('display_errors', 1);

/*
  Classe anonyme : pratique pour stubs/mocks ou composition locale ponctuelle.
*/
$worker = new class("Job-42") {
    public function __construct(private string $jobId){}
    public function run(){ echo "Running " . $this->jobId . PHP_EOL; }
};

$worker->run();
```

*(R√©f√©rence : cr√©ation et usage de classes anonymes )*

---

## 16) Synth√®se pratique (mini-projet en 1 fichier)

**But :** combiner **interfaces + classe abstraite + trait + impl√©mentation + it√©ration + clonage**.

Cr√©er le fichier **16_synthese_mini_projet.php** :

```php
<?php
error_reporting(E_ALL);
ini_set('display_errors', 1);

/* 1) Contrats et briques r√©utilisables */
interface Renderable { public function render(): string; }
trait IdTrait { private static int $auto=1; protected int $id; protected function bootId(){ $this->id=self::$auto++; }}

/* 2) Abstraction */
abstract class Item implements Renderable, Iterator {
    use IdTrait;
    protected array $meta = [];
    private int $pos = 0;

    public function __construct(protected string $title, protected float $price) { $this->bootId(); }

    // Iterator minimal
    public function rewind(): void { $this->pos=0; }
    public function current(): mixed { return array_values($this->meta)[$this->pos] ?? null; }
    public function key(): mixed { return array_keys($this->meta)[$this->pos] ?? null; }
    public function next(): void { ++$this->pos; }
    public function valid(): bool { return $this->pos < count($this->meta); }

    public function addMeta(string $k, mixed $v): void { $this->meta[$k]=$v; }
    abstract public function render(): string;

    // Deep clone : duplique le tableau pour l‚Äôexemple (inutile ici mais didactique)
    public function __clone(){ $this->meta = array_map(fn($v)=>$v, $this->meta); }
}

/* 3) Impl√©mentation concr√®te */
class Ebook extends Item {
    public function __construct(string $title, float $price, private string $format) {
        parent::__construct($title,$price);
        $this->addMeta('format',$this->format);
    }
    public function render(): string { return "#{$this->id} {$this->title} ({$this->format}) ‚Äì {$this->price}‚Ç¨"; }
}

/* 4) D√©monstration */
$e = new Ebook("PHP OOP Handbook", 29.0, "EPUB");
echo $e->render() . PHP_EOL;

// it√©ration sur les meta
foreach ($e as $k=>$v) { echo "$k: $v" . PHP_EOL; }

// clonage puis modification ind√©pendante
$e2 = clone $e;
$e2->addMeta('license','Site-wide');
echo $e2->render() . PHP_EOL;
```

---

## 17) Conseils & pi√®ges rapides (pratique)

- Pr√©f√©rez `public/protected/private` explicites plut√¥t que `var` (gard√© ici pour fid√©lit√© au contenu historique).

- Utilisez `parent::__construct()` pour cha√Æner les initialisations.

- Pour **emp√™cher** l‚Äôoverride : `final public function ...` ; pour **emp√™cher** l‚Äôh√©ritage : `final class ...`.

- Impl√©mentez `Iterator` si l‚Äôobjet doit √™tre parcouru en `foreach`.

- Pour √©viter les surprises au clonage : impl√©mentez `__clone()` et copiez **profond√©ment** tous les sous-objets n√©cessaires (deep copy).

---

## 18) V√©rification rapide

- En ligne de commande :
  
  ```bash
  php 01_classes_objets.php
  php 02_visibilite.php
  ...
  php 16_synthese_mini_projet.php
  ```

- Sous VS Code : ouvrir le dossier, cr√©er les fichiers list√©s, **ex√©cuter** via le terminal int√©gr√© (`php nom_fichier.php`).

---

### ‚úÖ Comp√©tences acquises

- Conception de classes robustes (propri√©t√©s, m√©thodes, `$this`, `->`).

- Ma√Ætrise de la **visibilit√©**, des **constructeurs/destructeurs**, de l‚Äô**h√©ritage** et de l‚Äô**override**.

- Usage de `static`, `self::`, `final`.

- Impl√©mentation d‚Äô**interfaces** (y compris **constantes d‚Äôinterface**), **classes abstraites** et **traits**.

- **Surcharge via m√©thodes magiques**, **it√©ration d‚Äôobjets**, **clonage shallow/deep**, **classes anonymes**.
