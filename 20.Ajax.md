# Atelier - PHP - Introduction à AJAX

Les applications web alimentées par PHP utilisent souvent AJAX ; ensemble, ils sont utiles pour créer des applications web dynamiques et interactives.

- AJAX signifie Asynchronous JavaScript and XML. Il permet aux pages web d’être mises à jour de manière asynchrone sans recharger la page entière.

- Dans les applications AJAX, l’échange de données entre un navigateur web et le script PHP côté serveur est asynchrone. 

- PHP est un langage de script côté serveur qui peut être utilisé pour générer du contenu dynamique et traiter des données.

- AJAX crée une couche supplémentaire connue sous le nom de moteur AJAX entre l’application web et le serveur web, ce qui permet d’effectuer des appels serveur en arrière-plan en utilisant JavaScript et de récupérer les données requises, de mettre à jour la portion demandée d’une page web sans recharger la page entière. Cela réduit le temps de rafraîchissement de la page et fournit une expérience rapide et réactive à l’utilisateur.

![Introduction PHP AJAX](https://www.tutorialspoint.com/php/images/php_ajax_introduction.jpg)

## Qu’est-ce qui est requis pour exécuter AJAX ?

Les technologies utilisées par AJAX sont déjà implémentées dans tous les navigateurs modernes. Donc, le client n’a pas besoin de module supplémentaire pour exécuter l’application AJAX. Les technologies utilisées par AJAX sont :

- **JavaScript*** : C’est une partie importante d’AJAX. Il permet de créer des fonctionnalités côté client. Ou nous pouvons dire qu’il est utilisé pour créer des applications AJAX.
- **XML*** : Il est utilisé pour échanger des données entre le serveur web et le client.
- **XMLHttpRequest*** : Il est utilisé pour effectuer un échange de données asynchrone entre un navigateur web et un serveur web.
- **HTML et CSS*** : Il est utilisé pour fournir du markup et du style au texte de la page web.
- **DOM*** : Il est utilisé pour interagir avec et modifier la mise en page et le contenu de la page web de manière dynamique. 

## 1) Introduction à AJAX (XMLHttpRequest → JSON/HTML)

**Idée clé :** JavaScript (navigateur) envoie une requête **asynchrone** au serveur PHP via `XMLHttpRequest` (ou `fetch`). Le serveur renvoie JSON/HTML, la page se met à jour **sans rechargement**.

Créer le fichier **intro.html** :

```html
<!--
But : Démontrer un appel AJAX GET simple, réponse JSON, mise à jour du DOM.
Test : http://localhost/atelier-ajax/intro.html
-->
<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>AJAX Intro</title>
</head>
<body>
  <h1>AJAX + PHP (GET JSON)</h1>

  <!-- Zone d’affichage -->
  <p id="output">En attente…</p>

  <!-- Bouton déclencheur -->
  <button id="btn">Dire bonjour</button>

  <script>
    // Récupère les éléments
    const btn = document.getElementById('btn');
    const out = document.getElementById('output');

    // Au clic : appel AJAX GET vers PHP
    btn.addEventListener('click', () => {
      // 1) Créer l’objet XHR
      const xhr = new XMLHttpRequest();

      // 2) Préparer la requête : GET vers hello.php?name=Bechir
      xhr.open('GET', 'intro_hello.php?name=Bechir', true);

      // 3) Sur réponse reçue
      xhr.onload = function () {
        // Status 200 = OK
        if (xhr.status === 200) {
          // La réponse est du JSON => parse
          const data = JSON.parse(xhr.responseText);
          // Mettre à jour le DOM
          out.textContent = data.message; // ex : "Bonjour, Bechir !"
        } else {
          out.textContent = 'Erreur côté serveur';
        }
      };

      // 4) Envoyer la requête
      xhr.send();
    });
  </script>
</body>
</html>
```

Créer le fichier **intro_hello.php** :

```php
<?php
/*
But : Recevoir name via GET, renvoyer JSON : { "message": "Bonjour, <name> !" }
Sécurité : htmlspecialchars sur l’entrée utilisateur, header JSON.
*/

header('Content-Type: application/json; charset=utf-8');

// 1) Lire l’entrée GET (avec valeur par défaut)
$name = isset($_GET['name']) ? $_GET['name'] : 'Anonyme';

// 2) Sécuriser un minimum l’affichage
$name = htmlspecialchars($name, ENT_QUOTES, 'UTF-8');

// 3) Construire la réponse
$response = [
  'message' => "Bonjour, $name !"
];

// 4) Retourner JSON
echo json_encode($response, JSON_UNESCAPED_UNICODE);
```

---

## 2) Recherche AJAX (live search, réponse texte)

**Idée clé :** À chaque frappe (`keyup`), on envoie une requête GET avec la chaîne tapée, le PHP filtre un tableau et renvoie la **liste des correspondances** (texte simple ou HTML).

Créer le fichier **search.html** :

```html
<!--
But : Champ de recherche avec auto-suggestion simple (texte).
Test : http://localhost/atelier-ajax/search.html
-->
<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>Recherche AJAX (live)</title>
  <style>
    #hint { color: green; }
    input { width: 320px; padding: 6px; }
  </style>
</head>
<body>
  <h2>Recherchez vos tutoriels préférés :</h2>
  <input type="text" id="q" placeholder="Tapez un mot-clé…" autocomplete="off">
  <p>Correspondances : <span id="hint"></span></p>

  <script>
    const q = document.getElementById('q');
    const hint = document.getElementById('hint');
    let timer = null;

    q.addEventListener('keyup', () => {
      // Débouncing léger pour éviter trop d’appels
      clearTimeout(timer);
      timer = setTimeout(() => {
        const val = q.value.trim();

        // Si vide => vider l’affichage
        if (val.length === 0) {
          hint.textContent = '';
          return;
        }

        // Préparer XHR
        const xhr = new XMLHttpRequest();
        xhr.open('GET', 'search.php?q=' + encodeURIComponent(val), true);
        xhr.onload = function () {
          if (xhr.status === 200) {
            // Réponse texte (CSV simple ou message)
            hint.textContent = xhr.responseText;
          } else {
            hint.textContent = 'Erreur';
          }
        };
        xhr.send();
      }, 200);
    });
  </script>
</body>
</html>
```

Créer le fichier **search.php** :

```php
<?php
/*
But : Recevoir q (chaîne) puis retourner correspondances (séparées par ", ").
Note : Exemple simple en mémoire. Remplacer par une requête SQL selon besoin.
*/

header('Content-Type: text/plain; charset=utf-8');

$catalog = [
  "Android","Langage de programmation B","Langage de programmation C","Langage de programmation D",
  "euphoria","F#","GWT","HTML5","ibatis","Java","Langage de programmation K","Lisp",
  "Technologies Microsoft","Réseaux","Open Source","Prototype","QC","Services web RESTful","Scrum",
  "Test","UML","VB Script","Technologies web","Technologie Xerox","YQL","ZOPL"
];

// 1) Lire q
$q = isset($_GET['q']) ? trim($_GET['q']) : '';
if ($q === '') {
  echo 'Veuillez entrer un nom de cours valide';
  exit;
}

// 2) Filtrer (insensible à la casse) par préfixe
$qLower = mb_strtolower($q, 'UTF-8');
$len = mb_strlen($qLower, 'UTF-8');
$matches = [];

foreach ($catalog as $name) {
  $prefix = mb_strtolower(mb_substr($name, 0, $len, 'UTF-8'), 'UTF-8');
  if ($prefix === $qLower) {
    $matches[] = $name;
  }
}

// 3) Répondre
if (empty($matches)) {
  echo 'Aucune correspondance';
} else {
  echo implode(', ', $matches);
}
```

---

## 3) Auto-complétion AJAX + XML (parser DOM côté PHP)

**Idée clé :** On stocke les suggestions dans un **XML**, le JavaScript interroge PHP à chaque frappe, le PHP **parse le XML**, filtre et renvoie le résultat (HTML ou texte).

Créer le fichier **autocomplete.xml** :

```xml
<!--
But : Source de données pour l’auto-complétion (format XML simple).
Placement : même dossier que index_autocomplete.php
-->
<?xml version="1.0" encoding="utf-8"?>
<pages>
  <link><title>android</title><url>https://www.tutorialspoint.com/android/index.htm</url></link>
  <link><title>Java</title><url>https://www.tutorialspoint.com/java/index.htm</url></link>
  <link><title>CSS</title><url>https://www.tutorialspoint.com/css/index.htm</url></link>
  <link><title>angular</title><url>https://www.tutorialspoint.com/angularjs/index.htm</url></link>
  <link><title>hadoop</title><url>https://www.tutorialspoint.com/hadoop/index.htm</url></link>
  <link><title>swift</title><url>https://www.tutorialspoint.com/swift/index.htm</url></link>
  <link><title>ruby</title><url>https://www.tutorialspoint.com/ruby/index.htm</url></link>
  <link><title>nodejs</title><url>https://www.tutorialspoint.com/nodejs/index.htm</url></link>
</pages>
```

Créer le fichier **index_autocomplete.php** :

```php
<?php
/*
But : Page avec champ texte et zone de résultats.
JS appelle livesearch.php?q=... à chaque frappe.
Test : http://localhost/atelier-ajax/index_autocomplete.php
*/
?><!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>Auto-complétion AJAX + XML</title>
  <style>
    #livesearch { border: 1px solid #A5ACB2; padding: 6px; min-height: 24px; }
    input { width: 340px; padding: 6px; }
  </style>
</head>
<body>
  <h2>Entrez le nom du cours</h2>
  <input type="text" size="30" id="q" placeholder="ex: java, css, nodejs">
  <div id="livesearch">Suggestions…</div>

  <script>
    const q = document.getElementById('q');
    const box = document.getElementById('livesearch');
    let timer = null;

    q.addEventListener('keyup', () => {
      clearTimeout(timer);
      const val = q.value.trim();
      if (val.length === 0) {
        box.textContent = '';
        return;
      }
      timer = setTimeout(() => {
        const xhr = new XMLHttpRequest();
        xhr.open('GET', 'livesearch.php?q=' + encodeURIComponent(val), true);
        xhr.onload = function () {
          if (xhr.status === 200) box.innerHTML = xhr.responseText;
          else box.textContent = 'Erreur';
        };
        xhr.send();
      }, 200);
    });
  </script>
</body>
</html>
```

Créer le fichier **livesearch.php** :

```php
<?php
/*
But : Charger autocomplete.xml, filtrer par q (insensible à la casse),
rendre la liste des liens correspondants au format HTML.
*/

header('Content-Type: text/html; charset=utf-8');

// 1) Lire q
$q = isset($_GET['q']) ? trim($_GET['q']) : '';
if ($q === '') {
  echo 'Aucun enregistrement trouvé.';
  exit;
}

// 2) Charger le XML
$xml = new DOMDocument();
$xml->load(__DIR__ . '/autocomplete.xml');
$links = $xml->getElementsByTagName('link');

$qLower = mb_strtolower($q, 'UTF-8');
$out = [];

// 3) Parcourir les nœuds <link>
foreach ($links as $node) {
  $title = $node->getElementsByTagName('title')->item(0)->nodeValue ?? '';
  $url   = $node->getElementsByTagName('url')->item(0)->nodeValue ?? '';
  if (stripos($title, $qLower) !== false) {
    // Ajouter un lien cliquable
    $t = htmlspecialchars($title, ENT_QUOTES, 'UTF-8');
    $u = htmlspecialchars($url, ENT_QUOTES, 'UTF-8');
    $out[] = "<div><a href=\"$u\" target=\"_blank\">$t</a></div>";
  }
}

// 4) Rendre la réponse
echo empty($out) ? 'Aucun enregistrement trouvé.' : implode('', $out);
```

---

## 4) Flux RSS AJAX (chargement côté PHP + affichage dynamique)

**Idée clé :** JavaScript appelle `rss.php?q=…`, le PHP récupère le flux RSS **externe** (Internet requis), parse et renvoie un **extrait HTML**.

Créer le fichier **rss.html** :

```html
<!--
But : Sélection d’une source RSS → appel AJAX → rendu d’un extrait.
Test : http://localhost/atelier-ajax/rss.html (connexion Internet requise)
-->
<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>Flux RSS via AJAX</title>
</head>
<body>
  <p>Sélectionnez un flux RSS :</p>
  <select id="sel">
    <option value="">-- choisissez --</option>
    <option value="cnn">CNN</option>
    <option value="bbc">BBC News</option>
    <option value="pcw">PC World</option>
  </select>

  <div id="output" style="margin-top:1rem;">Flux RSS…</div>

  <script>
    const sel = document.getElementById('sel');
    const out = document.getElementById('output');

    sel.addEventListener('change', () => {
      const v = sel.value;
      if (!v) { out.textContent = ''; return; }

      const xhr = new XMLHttpRequest();
      xhr.open('GET', 'rss.php?q=' + encodeURIComponent(v), true);
      xhr.onload = function () {
        out.innerHTML = (xhr.status === 200) ? xhr.responseText : 'Erreur';
      };
      xhr.send();
    });
  </script>
</body>
</html>
```

Créer le fichier **rss.php** :

```php
<?php
/*
But : Charger un flux RSS externe selon q ∈ {cnn, bbc, pcw}, parser quelques items,
rendre un extrait HTML. Nécessite allow_url_fopen=On ou cURL.
*/

header('Content-Type: text/html; charset=utf-8');

// 1) Choisir l’URL du flux selon q
$q = isset($_GET['q']) ? $_GET['q'] : '';
switch ($q) {
  case 'cnn':
    $url = 'http://rss.cnn.com/rss/cnn_topstories.rss';
    break;
  case 'bbc':
    $url = 'http://feeds.bbci.co.uk/news/world/rss.xml';
    break;
  case 'pcw':
    $url = 'https://www.pcworld.com/index.rss';
    break;
  default:
    echo 'Flux inconnu.';
    exit;
}

// 2) Charger le XML (DOM)
$doc = new DOMDocument();
libxml_use_internal_errors(true);
$ok = $doc->load($url);
libxml_clear_errors();

if (!$ok) {
  echo 'Impossible de charger le flux.';
  exit;
}

// 3) Extraire <channel> et 3 premiers <item>
$channel = $doc->getElementsByTagName('channel')->item(0);
if (!$channel) { echo 'Flux invalide.'; exit; }

$title = $channel->getElementsByTagName('title')->item(0)->nodeValue ?? '';
$link  = $channel->getElementsByTagName('link')->item(0)->nodeValue ?? '';
$desc  = $channel->getElementsByTagName('description')->item(0)->nodeValue ?? '';

echo '<p><a href="' . htmlspecialchars($link) . '" target="_blank">'
   . htmlspecialchars($title) . '</a><br>'
   . htmlspecialchars($desc) . '</p>';

$items = $doc->getElementsByTagName('item');
for ($i = 0; $i < min(3, $items->length); $i++) {
  $it = $items->item($i);
  $itTitle = $it->getElementsByTagName('title')->item(0)->nodeValue ?? '';
  $itLink  = $it->getElementsByTagName('link')->item(0)->nodeValue ?? '';
  $itDesc  = $it->getElementsByTagName('description')->item(0)->nodeValue ?? '';
  echo '<p><a href="' . htmlspecialchars($itLink) . '" target="_blank">'
     . htmlspecialchars($itTitle) . '</a><br>'
     . $itDesc . '</p>';
}
```

---

## 5) Analyseur XML AJAX (sélection → détails depuis XML local)

**Idée clé :** Un `<select>` envoie la valeur au PHP, qui **parcourt un XML local** et renvoie les détails du cours sélectionné.

Créer le fichier **catalog.xml** :

```xml
<!--
But : Catalogue local pour l’exemple d’analyse XML.
-->
<?xml version="1.0" encoding="utf-8"?>
<CATALOG>
  <SUBJECT><COURSE>Android</COURSE><COUNTRY>Inde</COUNTRY><COMPANY>TutorialsPoint</COMPANY><PRICE>$10</PRICE><YEAR>2015</YEAR></SUBJECT>
  <SUBJECT><COURSE>Html</COURSE><COUNTRY>Inde</COUNTRY><COMPANY>TutorialsPoint</COMPANY><PRICE>$15</PRICE><YEAR>2015</YEAR></SUBJECT>
  <SUBJECT><COURSE>Java</COURSE><COUNTRY>Inde</COUNTRY><COMPANY>TutorialsPoint</COMPANY><PRICE>$20</PRICE><YEAR>2015</YEAR></SUBJECT>
  <SUBJECT><COURSE>Microsoft</COURSE><COUNTRY>Inde</COUNTRY><COMPANY>TutorialsPoint</COMPANY><PRICE>$25</PRICE><YEAR>2015</YEAR></SUBJECT>
</CATALOG>
```

Créer le fichier **xml_select.html** :

```html
<!--
But : Sélection d’un cours → AJAX → détails affichés.
Test : http://localhost/atelier-ajax/xml_select.html
-->
<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>Analyse XML AJAX</title>
</head>
<body>
  <h3>Sélectionnez un cours :</h3>
  <select id="course">
    <option value="">-- choisissez --</option>
    <option value="Android">Android</option>
    <option value="Html">HTML</option>
    <option value="Java">Java</option>
    <option value="Microsoft">Technologies MS</option>
  </select>

  <div id="info" style="margin-top:1rem;"><b>Les infos du cours seront listées ici…</b></div>

  <script>
    const sel = document.getElementById('course');
    const info = document.getElementById('info');

    sel.addEventListener('change', () => {
      const v = sel.value;
      if (!v) { info.textContent = ''; return; }

      const xhr = new XMLHttpRequest();
      xhr.open('GET', 'xml_details.php?q=' + encodeURIComponent(v), true);
      xhr.onload = function () {
        info.innerHTML = (xhr.status === 200) ? xhr.responseText : 'Erreur';
      };
      xhr.send();
    });
  </script>
</body>
</html>
```

Créer le fichier **xml_details.php** :

```php
<?php
/*
But : Charger catalog.xml, trouver le SUBJECT dont <COURSE> == q,
rendre toutes ses infos en HTML.
*/

header('Content-Type: text/html; charset=utf-8');

$q = isset($_GET['q']) ? trim($_GET['q']) : '';
if ($q === '') { echo 'Choix invalide.'; exit; }

$xmlDoc = new DOMDocument();
$xmlDoc->load(__DIR__ . '/catalog.xml');

$subjects = $xmlDoc->getElementsByTagName('SUBJECT');
$found = null;

// Chercher le SUBJECT correspondant
foreach ($subjects as $subj) {
  $courseNode = $subj->getElementsByTagName('COURSE')->item(0);
  if ($courseNode && $courseNode->nodeValue === $q) {
    $found = $subj;
    break;
  }
}

if (!$found) { echo 'Aucun enregistrement trouvé.'; exit; }

// Lister tous les enfants du SUBJECT
$out = '';
foreach ($found->childNodes as $node) {
  if ($node->nodeType === XML_ELEMENT_NODE) {
    $name = htmlspecialchars($node->nodeName, ENT_QUOTES, 'UTF-8');
    $val  = htmlspecialchars($node->nodeValue, ENT_QUOTES, 'UTF-8');
    $out .= "<b>$name :</b> $val<br>";
  }
}
echo $out;
```

---

## 6) Post-Redirect-Get (PRG) — éviter la resoumission

**Idée clé :** Après un `POST`, on **redirige** vers une page en `GET`. Si l’utilisateur rafraîchit, **aucune resoumission**.

Créer le fichier **prg_form.php** :

```php
<?php
/*
But : Formulaire simple soumis en POST vers prg_handle.php.
Test : http://localhost/atelier-ajax/prg_form.php
*/
?><!doctype html>
<html lang="fr">
<head><meta charset="utf-8"><title>PRG</title></head>
<body>
  <h3>Formulaire PRG</h3>
  <form action="prg_handle.php" method="post">
    Prénom : <input type="text" name="first_name" required><br>
    Nom : <input type="text" name="last_name" required><br>
    <button type="submit" name="submit">Soumettre</button>
  </form>
</body>
</html>
```

Créer le fichier **prg_handle.php** :

```php
<?php
/*
But : En POST, stocker en session puis rediriger vers prg_result.php (GET).
*/

session_start();

if ($_SERVER['REQUEST_METHOD'] === 'POST' && isset($_POST['submit'])) {
  $_SESSION['fname'] = $_POST['first_name'] ?? '';
  $_SESSION['lname'] = $_POST['last_name'] ?? '';
  header('Location: prg_result.php'); // Redirection (GET)
  exit;
}

// Accès direct interdit
header('Location: prg_form.php');
```

Créer le fichier **prg_result.php** :

```php
<?php
/*
But : Afficher et nettoyer les données de session. Rafraîchir la page ne resoumet pas.
*/

session_start();
$fname = $_SESSION['fname'] ?? null;
$lname = $_SESSION['lname'] ?? null;
unset($_SESSION['fname'], $_SESSION['lname']);
?><!doctype html>
<html lang="fr">
<head><meta charset="utf-8"><title>PRG Résultat</title></head>
<body>
<?php if ($fname && $lname): ?>
  <p>Prénom : <?= htmlspecialchars($fname, ENT_QUOTES, 'UTF-8') ?>
     — Nom : <?= htmlspecialchars($lname, ENT_QUOTES, 'UTF-8') ?></p>
<?php else: ?>
  <p>Aucune donnée. <a href="prg_form.php">Revenir au formulaire</a></p>
<?php endif; ?>
</body>
</html>
```

---

## 7) Messages Flash (via `$_SESSION`, s’affichent une fois)

**Idée clé :** Enregistrer un message en session, le **consommer** et l’effacer à la page suivante (feedback utilisateur après action).

Créer le fichier **flash.php** :

```php
<?php
/*
But : Fonctions utilitaires pour messages flash.
Usage :
  flash_set('success', 'Enregistré');  // sur la page qui traite
  // Redirect …
  flash_show();                        // sur la page suivante
*/

session_start();

// Espace de noms interne pour éviter collisions
const FLASH = '__FLASH__';

// Crée ou remplace un message par nom (ex: 'success')
function flash_set(string $name, string $message): void {
  $_SESSION[FLASH][$name] = ['message' => $message];
}

// Affiche un message par nom (et le supprime)
function flash_display(string $name): void {
  if (!isset($_SESSION[FLASH][$name])) return;
  $msg = $_SESSION[FLASH][$name]['message'] ?? '';
  unset($_SESSION[FLASH][$name]);
  echo '<div style="padding:8px;border:1px solid #0a0;color:#efe;">'
     . htmlspecialchars($msg, ENT_QUOTES, 'UTF-8')
     . '</div>';
}

// Affiche tous les messages (et les supprime)
function flash_show(): void {
  if (empty($_SESSION[FLASH])) return;
  foreach ($_SESSION[FLASH] as $n => $arr) {
    $msg = $arr['message'] ?? '';
    echo '<div style="padding:8px;border:1px solid #06c;color:#eef;background:#06c;">'
       . htmlspecialchars($msg, ENT_QUOTES, 'UTF-8')
       . '</div>';
  }
  unset($_SESSION[FLASH]);
}
```

Créer le fichier **flash_set_example.php** :

```php
<?php
/*
But : Démontrer un set + redirect + show.
Test : http://localhost/atelier-ajax/flash_set_example.php
*/
require __DIR__ . '/flash.php';

// Simuler une sauvegarde réussie, puis rediriger
flash_set('success', 'Données sauvegardées avec succès !');
header('Location: flash_show_example.php');
exit;
```

Créer le fichier **flash_show_example.php** :

```php
<?php
/*
But : Afficher les messages flash (une seule fois).
*/
require __DIR__ . '/flash.php';
?><!doctype html>
<html lang="fr">
<head><meta charset="utf-8"><title>Messages flash</title></head>
<body>
  <h3>Résultat de l’opération</h3>
  <?php flash_show(); ?>
  <p><a href="flash_set_example.php">Rejouer la démonstration</a></p>
</body>
</html>
```

---

## Vérification rapide

1. Placez tous les fichiers dans `htdocs/atelier-ajax/` (XAMPP).

2. Lancez Apache, puis testez :
- `intro.html` (intro AJAX)

- `search.html` (live search)

- `index_autocomplete.php` (auto-complétion + XML)

- `rss.html` (RSS, Internet requis)

- `xml_select.html` (analyse XML local)

- `prg_form.php` (PRG)

- `flash_set_example.php` puis `flash_show_example.php` (messages flash)

---

## Compétences acquises

- Appels AJAX (`XMLHttpRequest`) vers PHP et **mise à jour partielle** du DOM

- **JSON** et **HTML** côté réponse, parsing côté client

- Lecture/écriture d’entrées (`$_GET`, `$_POST`), **sécurisation minimale** (`htmlspecialchars`)

- Parsing **XML** côté serveur avec **DOMDocument**

- Intégration de **flux RSS** externes (DOM + Internet)

- **PRG** (Post-Redirect-Get) pour éviter la resoumission

- **Messages flash** avec `$_SESSION` (feedback utilisateur propre)

> 
