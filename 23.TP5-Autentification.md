# ğŸ“ TP7 â€”  MÃ©thodes d'authentification

## Cas 1: MÃ©thode d'authentification par session

## ğŸ¯ Objectifs

- Servir des donnÃ©es **JSON** et **XML** depuis votre app (mÃªme domaine).

- Consommer ces donnÃ©es cÃ´tÃ© **front** avec `fetch()` (AJAX) pour rafraÃ®chir sans recharger la page.

- Mettre en place une **authentification par session** (login/logout) protÃ©geant certaines actions (ex. ajout dâ€™utilisateur).

- Garder **Composer (PSR-4)** et lâ€™architecture propre (Repository JSON/SQLite dÃ©jÃ  faits).

> PrÃ©-requis : TP6 + TP6 (suite) fonctionnels (autoload PSR-4 actif).

---

## 1) Structure cible

```
tp7-app/ (vous pouvez Ã©voluer depuis tp6-app)
â”œâ”€â”€ composer.json                 (autoload PSR-4 "App\\": "src/")
â”œâ”€â”€ data/
â”‚   â”œâ”€â”€ users.json                (si repo=json)
â”‚   â””â”€â”€ app.db                    (si repo=sqlite)
â”œâ”€â”€ public/
â”‚   â”œâ”€â”€ index.php                 (UI + fetch AJAX)
â”‚   â”œâ”€â”€ login.php                 (formulaire HTML + POST)
â”‚   â”œâ”€â”€ logout.php                (dÃ©connexion)
â”‚   â””â”€â”€ api.php                   (endpoints JSON/XML sÃ©curisÃ©s)
â””â”€â”€ src/
    â”œâ”€â”€ App.php                   (inchangÃ© depuis TP6 suite)
    â”œâ”€â”€ Services/
    â”‚   â”œâ”€â”€ SessionManager.php    (existant)
    â”‚   â””â”€â”€ AuthService.php       (NOUVEAU)
    â”œâ”€â”€ Interfaces/               (Authentifiable.php, UserRepository.php)
    â”œâ”€â”€ Domain/                   (UserRecord.php)
    â”œâ”€â”€ Core/                     (Utilisateur + Admin/Membre/Visiteur)
    â””â”€â”€ Repositories/             (FileUserRepository + SqliteUserRepository)
```

---

## 2) Service dâ€™authentification

CrÃ©er le fichier **src/Services/AuthService.php** :

```php
<?php
namespace App\Services;

/**
 * AuthService â€” Authentification simple par sessions.
 * - Utilise SessionManager (dÃ©marrage, set/get, destroy).
 * - DÃ©mo pÃ©dagogique : identifiants codÃ©s en dur (Ã  remplacer par une base/LDAP plus tard).
 */
class AuthService
{
    private const USERS = [
        // login => password (hashÃ©s en prod ! Ici pour dÃ©mo : clair)
        'admin'  => 'admin123',
        'membre' => 'membre123',
    ];

    /** Retourne true si un utilisateur est connectÃ© */
    public static function isLogged(): bool
    {
        SessionManager::demarrer();
        return (bool) SessionManager::get('auth_user');
    }

    /** Retourne le login courant ou null */
    public static function currentUser(): ?string
    {
        SessionManager::demarrer();
        return SessionManager::get('auth_user');
    }

    /** Tentative de login : true si OK */
    public static function login(string $login, string $password): bool
    {
        SessionManager::demarrer();

        // âš ï¸ DÃ©mo : check simple (en prod : hash, rate limit, CSRF, etc.)
        if (isset(self::USERS[$login]) && self::USERS[$login] === $password) {
            SessionManager::set('auth_user', $login);
            return true;
        }
        return false;
    }

    /** DÃ©connexion */
    public static function logout(): void
    {
        SessionManager::demarrer();
        SessionManager::detruire();
    }

    /**
     * Protection d'action : lÃ¨ve une erreur si non connectÃ©
     * Ã€ utiliser cÃ´tÃ© API pour les routes protÃ©gÃ©es.
     */
    public static function requireLogin(): void
    {
        if (!self::isLogged()) {
            http_response_code(401);
            header('Content-Type: application/json; charset=utf-8');
            echo json_encode(['error' => 'auth_required'], JSON_UNESCAPED_UNICODE);
            exit;
        }
    }
}
```

---

## 3) Page dâ€™accueil (UI + AJAX)

CrÃ©er le fichier **public/index.php** :

> Pour externaliser le css dans un fichier css sÃ©parÃ©
> 
> ```css
> <head>
>     <link rel="stylesheet" href="style.css">
> </head>
> ```

```php
<?php
require __DIR__ . '/../vendor/autoload.php';

use App\Services\AuthService;

// Vue HTML principale avec un peu de JS (fetch) pour dÃ©montrer l'AJAX JSON/XML.
$logged = AuthService::isLogged();
$user   = AuthService::currentUser();
?>
<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>TP7 â€” Web dynamique, AJAX & Auth</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- CSS minimaliste externe recommandÃ© ; ici inline pour compacitÃ© -->
  <style>
    body{font-family:system-ui,Arial;margin:32px;background:#f6f8fb}
    .card{max-width:980px;margin:auto;background:#fff;padding:24px;border-radius:12px;
          box-shadow:0 8px 24px rgba(0,0,0,.08)}
    .row{display:flex;gap:16px;flex-wrap:wrap}
    .box{flex:1 1 300px;background:#fafbff;border:1px solid #e7ebf3;padding:16px;border-radius:10px}
    h1{margin-top:0}
    table{border-collapse:collapse;width:100%;background:#fff}
    th,td{padding:8px;border:1px solid #e1e6ef}
    th{background:#0b63d1;color:#fff}
    .muted{color:#6b7280}
    .ok{color:#177245}
    .warn{color:#b00}
    a{color:#0b63d1;text-decoration:none}
    a:hover{text-decoration:underline}
    input,select,button{padding:8px;border:1px solid #cbd5e1;border-radius:8px}
    .actions a{margin-right:10px}
  </style>
</head>
<body>
<div class="card">
  <h1>TP7 â€” Web dynamique (AJAX JSON/XML) & Authentification</h1>

  <div class="row">
    <div class="box">
      <h3>Authentification</h3>
      <?php if ($logged): ?>
        <p>ConnectÃ© en tant que <strong><?= htmlspecialchars($user) ?></strong></p>
        <p class="actions"><a href="/logout.php">Se dÃ©connecter</a></p>
      <?php else: ?>
        <p class="muted">Non connectÃ©</p>
        <p class="actions"><a href="/login.php">Se connecter</a></p>
      <?php endif; ?>
      <p class="muted">DÃ©mo : admin/admin123 â€” membre/membre123 (âš ï¸ dÃ©mo, pas prod)</p>
    </div>

    <div class="box">
      <h3>DÃ©pÃ´t de persistance actif</h3>
      <p>
        <a href="#" data-repo="json"  class="repoBtn">JSON</a> |
        <a href="#" data-repo="sqlite" class="repoBtn">SQLite</a>
      </p>
      <p id="repoState" class="muted">Inconnuâ€¦</p>
    </div>
  </div>

  <div class="row" style="margin-top:16px">
    <div class="box" style="flex:1 1 100%">
      <h3>Liste des utilisateurs (AJAX JSON)</h3>
      <p><button id="btnLoadJson">Charger via /api.php?fmt=json</button></p>
      <div id="jsonResult" class="muted">Cliquez pour chargerâ€¦</div>
    </div>
  </div>

  <div class="row" style="margin-top:16px">
    <div class="box">
      <h3>Liste (AJAX XML, parsing DOM)</h3>
      <p><button id="btnLoadXml">Charger via /api.php?fmt=xml</button></p>
      <ul id="xmlList" class="muted"></ul>
    </div>

    <div class="box">
      <h3>Ajout dâ€™utilisateur (protÃ©gÃ©)</h3>
      <p class="muted">NÃ©cessite Ãªtre connectÃ©</p>
      <div>
        <label>Nom : <input id="nameInput" placeholder="Nom..."></label>
        <label>Type :
          <select id="typeSelect">
            <option value="admin">admin</option>
            <option value="membre" selected>membre</option>
            <option value="visiteur">visiteur</option>
          </select>
        </label>
        <button id="btnAdd">Ajouter (AJAX POST)</button>
      </div>
      <pre id="addOut" class="muted" style="white-space:pre-wrap;margin-top:8px"></pre>
    </div>
  </div>
</div>

<script>
// -- util: rÃ©cupÃ©rer/poser le dÃ©pÃ´t choisi en localStorage (json/sqlite)
const repoKey = 'tp7-repo';
function getRepo() { return localStorage.getItem(repoKey) || 'json'; }
function setRepo(v){ localStorage.setItem(repoKey, v); updateRepoState(); }
function updateRepoState(){ document.getElementById('repoState').textContent = 'DÃ©pÃ´t: ' + getRepo(); }
updateRepoState();

// -- boutons de sÃ©lection du repo
document.querySelectorAll('.repoBtn').forEach(a=>{
  a.addEventListener('click', (e)=>{
    e.preventDefault();
    setRepo(a.dataset.repo);
  });
});

// -- AJAX JSON : GET /api.php?fmt=json&repo=...
document.getElementById('btnLoadJson').addEventListener('click', async ()=>{
  const out = document.getElementById('jsonResult');
  out.textContent = 'Chargementâ€¦';
  const res = await fetch('/api.php?fmt=json&action=list&repo=' + encodeURIComponent(getRepo()), {
    headers: { 'Accept': 'application/json' }
  });
  if (!res.ok) { out.textContent = 'Erreur ' + res.status; return; }
  const data = await res.json(); // { items: [ {nom, role, type}, ... ] }
  if (!Array.isArray(data.items)) { out.textContent = 'RÃ©ponse inattendue'; return; }

  // Remplir un tableau HTML
  let html = '<table><tr><th>Nom</th><th>RÃ´le</th><th>Type</th></tr>';
  for (const u of data.items) {
    html += `<tr><td>${escapeHtml(u.nom)}</td><td>${escapeHtml(u.role)}</td><td>${escapeHtml(u.type)}</td></tr>`;
  }
  html += '</table>';
  out.innerHTML = html;
});

// -- AJAX XML : GET /api.php?fmt=xml&repo=...
document.getElementById('btnLoadXml').addEventListener('click', async ()=>{
  const ul = document.getElementById('xmlList');
  ul.textContent = 'Chargementâ€¦';
  const res = await fetch('/api.php?fmt=xml&action=list&repo=' + encodeURIComponent(getRepo()), {
    headers: { 'Accept': 'application/xml' }
  });
  if (!res.ok) { ul.textContent = 'Erreur ' + res.status; return; }
  const text = await res.text();
  const doc  = new DOMParser().parseFromString(text, 'application/xml');
  const nodes = doc.querySelectorAll('user');
  ul.innerHTML = '';
  nodes.forEach(n=>{
    const li = document.createElement('li');
    li.textContent = `${n.getAttribute('nom')} â€” ${n.getAttribute('role')} [${n.getAttribute('type')}]`;
    ul.appendChild(li);
  });
});

// -- AJAX POST protÃ©gÃ© : POST /api.php?action=add  (nÃ©cessite login)
document.getElementById('btnAdd').addEventListener('click', async ()=>{
  const name = document.getElementById('nameInput').value.trim();
  const type = document.getElementById('typeSelect').value;
  const out  = document.getElementById('addOut');
  if (!name) { out.textContent = 'Saisir un nom.'; return; }

  const res = await fetch('/api.php?action=add&repo=' + encodeURIComponent(getRepo()), {
    method: 'POST',
    headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
    body: JSON.stringify({ nom: name, type })
  });
  const data = await res.json().catch(()=>({error:'json_failed'}));
  out.textContent = JSON.stringify(data, null, 2);
});

// -- helper XSS-safe
function escapeHtml(s){ return s?.replace(/[&<>"']/g, c => ({'&':'&','<':'<','>':'>','"':'"',"'":'&#039;'}[c])) ?? ''; }
</script>
</body>
</html>
```

**Ce que dÃ©montre cette page :**

- Chargement **AJAX JSON** et **AJAX XML**.

- **Ajout protÃ©gÃ©** via POST (nÃ©cessite login).

- **Choix du dÃ©pÃ´t** (json/sqlite) cÃ´tÃ© client, transmis Ã  lâ€™API.

---

## 4) Endpoints API (JSON & XML, avec protection)

CrÃ©er le fichier **public/api.php** :

```php
<?php
require __DIR__ . '/../vendor/autoload.php';

use App\Services\AuthService;
use App\Services\SessionManager;
use App\Repositories\FileUserRepository;
use App\Repositories\SqliteUserRepository;
use App\Domain\UserRecord;
use App\Core\Admin;
use App\Core\Membre;
use App\Core\Visiteur;

// -- DÃ©marrage session et CORS (mÃªme domaine => CORS non requis ; montrÃ© Ã  titre indicatif)
SessionManager::demarrer();

// -- SÃ©lection repo (comme TP6-s)
$repoName = $_GET['repo'] ?? getenv('APP_REPO') ?? 'json';
$repo = match (strtolower($repoName)) {
    'sqlite' => new SqliteUserRepository(),
    default  => new FileUserRepository(),
};

$fmt    = strtolower($_GET['fmt']    ?? 'json');   // json|xml
$action = strtolower($_GET['action'] ?? 'list');   // list|add|reset

// -- Routeur API minimaliste
switch ($action) {
    case 'list':
        $items = $repo->all(); // array<UserRecord>
        respond($fmt, 200, [
            'items' => array_map(fn($r)=>['nom'=>$r->nom,'role'=>$r->role,'type'=>$r->type], $items)
        ]);
        break;

    case 'add':
        // ğŸ” Protection : login requis
        AuthService::requireLogin();

        // RÃ©cupÃ©ration payload JSON
        $payload = json_decode(file_get_contents('php://input'), true) ?? [];
        $nom  = trim((string)($payload['nom']  ?? ''));
        $type = strtolower((string)($payload['type'] ?? ''));

        if ($nom === '' || !in_array($type, ['admin','membre','visiteur'], true)) {
            respond($fmt, 400, ['error' => 'invalid_input', 'hint' => 'nom + type in {admin,membre,visiteur}']);
        }

        // Polymorphisme : construire lâ€™objet OO
        $userObj = match ($type) {
            'admin'  => new Admin($nom, 'Administrateur'),
            'membre' => new Membre($nom, 'Membre'),
            default  => new Visiteur($nom, 'Visiteur'),
        };

        $repo->add(new UserRecord($userObj->getNom(), $userObj->getRole(), $type));
        respond($fmt, 201, [
            'ok'      => true,
            'message' => $userObj->seConnecter(),
            'role'    => $userObj->getRole(),
            'type'    => $type
        ]);
        break;

    case 'reset':
        // ğŸ” Protection : login requis
        AuthService::requireLogin();
        $repo->clear();
        respond($fmt, 200, ['ok'=>true,'message'=>'RÃ©initialisÃ©','repo'=>$repoName]);
        break;

    default:
        respond($fmt, 404, ['error'=>'not_found']);
}

// ---------- helpers de rÃ©ponse ----------

/**
 * RÃ©pond en JSON ou XML selon $fmt.
 * $data est un tableau associatif (clÃ© => valeur).
 */
function respond(string $fmt, int $status, array $data): void
{
    http_response_code($status);

    if ($fmt === 'xml') {
        header('Content-Type: application/xml; charset=utf-8');
        echo toXml($data, 'response');
        return;
    }

    // dÃ©faut: JSON
    header('Content-Type: application/json; charset=utf-8');
    echo json_encode($data, JSON_UNESCAPED_UNICODE | JSON_PRETTY_PRINT);
}

/** Transforme un array associatif simple en XML (dÃ©mo) */
function toXml(array $data, string $root = 'response'): string
{
    $xml = new SimpleXMLElement("<{$root}/>");

    $add = function($node, $key, $val) use (&$add) {
        if (is_array($val)) {
            // cas items: [...] => <items><item ... /></items>
            if (isSequential($val)) {
                $list = $node->addChild($key);
                foreach ($val as $entry) {
                    if (is_array($entry)) {
                        $item = $list->addChild('item');
                        foreach ($entry as $k=>$v) {
                            $item->addAttribute($k, (string)$v);
                        }
                    } else {
                        $list->addChild('item', htmlspecialchars((string)$entry));
                    }
                }
            } else {
                $child = $node->addChild($key);
                foreach ($val as $k=>$v) $add($child, $k, $v);
            }
        } else {
            $node->addChild($key, htmlspecialchars((string)$val));
        }
    };

    foreach ($data as $k=>$v) $add($xml, $k, $v);
    // Pour correspondre Ã  lâ€™exemple TP : transformer items/item en <users><user .../></users>
    // Optionnel: si la clÃ© "items" existe, renommer le conteneur
    $xmlStr = $xml->asXML();
    $xmlStr = str_replace('<items>', '<users>', $xmlStr);
    $xmlStr = str_replace('</items>', '</users>', $xmlStr);
    $xmlStr = str_replace('<item ', '<user ', $xmlStr);
    $xmlStr = str_replace('</item>', '</user>', $xmlStr);
    return $xmlStr;
}

function isSequential(array $a): bool
{
    return array_keys($a) === range(0, count($a)-1);
}
```

**Notes clÃ©s :**

- `action=list|add|reset` ; `fmt=json|xml` ; `repo=json|sqlite`.

- `add` et `reset` protÃ©gÃ©s par **AuthService::requireLogin()** â†’ 401 si non connectÃ©.

- Lâ€™XML est produit proprement ; pour la dÃ©mo on mappe `<items><item â€¦/></items>` en `<users><user â€¦/></users>`.

---

## 5) Login / Logout (formulaire simple)

CrÃ©er le fichier **public/login.php** :

```php
<?php
require __DIR__ . '/../vendor/autoload.php';

use App\Services\AuthService;

$error = null;

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    $login = trim($_POST['login'] ?? '');
    $pass  = trim($_POST['password'] ?? '');
    if (AuthService::login($login, $pass)) {
        header('Location: /');
        exit;
    }
    $error = "Identifiants incorrects";
}
?>
<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>Login â€” TP7</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body{font-family:system-ui,Arial;margin:32px;background:#f6f8fb}
    .card{max-width:420px;margin:auto;background:#fff;padding:24px;border-radius:12px;box-shadow:0 8px 24px rgba(0,0,0,.08)}
    input,button{width:100%;padding:10px;margin-top:8px;border:1px solid #cbd5e1;border-radius:8px}
    .err{color:#b00}
    a{color:#0b63d1;text-decoration:none}
  </style>
</head>
<body>
<div class="card">
  <h1>Connexion</h1>
  <?php if ($error): ?><p class="err"><?= htmlspecialchars($error) ?></p><?php endif; ?>
  <form method="post" action="/login.php">
    <input name="login" placeholder="login (admin|membre)" required>
    <input name="password" placeholder="mot de passe" type="password" required>
    <button type="submit">Se connecter</button>
  </form>
  <p><a href="/">Retour</a></p>
  <p style="color:#6b7280">DÃ©mo : admin/admin123 â€” membre/membre123</p>
</div>
</body>
</html>
```

CrÃ©er le fichier **public/logout.php** :

```php
<?php
require __DIR__ . '/../vendor/autoload.php';

use App\Services\AuthService;

AuthService::logout();
header('Location: /');
```

---

## 6) ScÃ©narios de test

1. **Charger JSON** sans Ãªtre connectÃ© :
   
   - Ouvrir `/` â†’ cliquer **â€œCharger via /api.php?fmt=jsonâ€** â†’ la table sâ€™affiche (public).

2. **Charger XML** :
   
   - Cliquer **â€œCharger via /api.php?fmt=xmlâ€** â†’ la liste `<user>` apparaÃ®t.

3. **Ajouter (protÃ©gÃ©)** sans login :
   
   - Cliquer â€œAjouter (AJAX POST)â€ â†’ rÃ©ponse `{"error":"auth_required"}` (HTTP 401).

4. **Se connecter** :
   
   - `/login.php` â†’ `admin/admin123` â†’ retour `/`.

5. **Ajouter (protÃ©gÃ©)** en Ã©tant connectÃ© :
   
   - Saisir un nom + type, **Ajouter** â†’ `{"ok":true, ...}` ; recharger la liste JSON/XML.

6. **Changer de dÃ©pÃ´t** (JSON â‡„ SQLite) :
   
   - Choisir **JSON** ou **SQLite** â†’ recharger la liste â†’ voir la source de donnÃ©es changer.

7. **Reset (protÃ©gÃ©)** :
   
   - Appeler `/api.php?action=reset&repo=sqlite` via un GET (ou ajoutez un bouton) â†’ 200 OK si connectÃ©.

---

## 7) Pourquoi ce TP est â€œformateurâ€

- **Data providers multiples (JSON/XML)** : vous montrez **deux formats** de sÃ©rialisation via **la mÃªme logique**.

- **AJAX** cÃ´tÃ© client : usage **moderne** et propre (`fetch`, parsing JSON/XML).

- **Auth par session** : diffÃ©rence claire entre **routes publiques** (list) et **protÃ©gÃ©es** (add/reset).

- **Composer toujours prÃ©sent** : organisation PSR-4, services injectables, repos interchangeables.

- **SÃ©paration des responsabilitÃ©s** : `api.php` pour lâ€™API, `index.php` pour lâ€™UI, services dÃ©diÃ©s pour auth/sessions.

---

## 8) Astuces & piÃ¨ges (et comment les anticiper)

- **401 sur add/reset malgrÃ© login** : vÃ©rifiez cookies/navigateur (mÃªme origine), et que `SessionManager::demarrer()` est appelÃ© (il lâ€™est).

- **CORS** : inutile en mÃªme domaine ; si front sÃ©parÃ© â†’ ajouter les en-tÃªtes CORS.

- **Prod** : ne jamais stocker des mots de passe en clair (utiliser `password_hash`, `password_verify`).

- **XML** : le parseur est strict ; bien envoyer `Content-Type: application/xml`.

- **SÃ©curitÃ© formulaire** : ajouter CSRF si vous passez en **POST HTML** (ici le POST est JSON cÃ´tÃ© API et mÃªme origine).

## Cas 2: MÃ©canisme d'authentification via Cookie

Voici **un exemple ultra simple, pÃ©dagogique, minimal** dâ€™authentification basÃ©e **uniquement sur un cookie**, sans session.

âš ï¸ Ce nâ€™est **pas un systÃ¨me sÃ©curisÃ©**, mais il sert Ã  comprendre la mÃ©canique.

---

# ğŸŸ¦ 1. Formulaire de connexion

CrÃ©er le fichier **login.php** :

```php
<?php
// Si le formulaire est soumis
if ($_SERVER["REQUEST_METHOD"] === "POST") {

    $username = $_POST["username"] ?? "";
    $password = $_POST["password"] ?? "";

    // Exemple simple : login = admin, password = 1234
    if ($username === "admin" && $password === "1234") {

        // On crÃ©e un cookie valable 1 heure
        // httpOnly = true empÃªche lâ€™accÃ¨s JS au cookie
        setcookie("auth_user", $username, time() + 3600, "/", "", false, true);

        // Redirection vers la page protÃ©gÃ©e
        header("Location: dashboard.php");
        exit;
    }

    $error = "Identifiants incorrects";
}
?>

<!DOCTYPE html>
<html>
<body>
<h2>Login</h2>

<?php if (!empty($error)) : ?>
<p style="color:red;"><?= $error ?></p>
<?php endif; ?>

<form method="post">
    <label>Utilisateur :</label>
    <input type="text" name="username" required><br><br>

    <label>Mot de passe :</label>
    <input type="password" name="password" required><br><br>

    <button type="submit">Se connecter</button>
</form>

</body>
</html>
```

---

# ğŸŸ¦ 2. Page protÃ©gÃ©e qui vÃ©rifie le cookie

CrÃ©er le fichier **dashboard.php** :

```php
<?php
// VÃ©rifier si le cookie existe
if (!isset($_COOKIE["auth_user"])) {
    header("Location: login.php");
    exit;
}

$user = htmlspecialchars($_COOKIE["auth_user"]);
?>

<!DOCTYPE html>
<html>
<body>

<h2>Bonjour <?= $user ?>, vous Ãªtes connectÃ© via un cookie !</h2>

<p><a href="logout.php">Se dÃ©connecter</a></p>

</body>
</html>
```

---

# ğŸŸ¦ 3. DÃ©connexion (suppression du cookie)

CrÃ©er le fichier **logout.php** :

```php
<?php
// Pour supprimer un cookie, on met une date expirÃ©e
setcookie("auth_user", "", time() - 3600, "/");

// Redirection
header("Location: login.php");
exit;
```

---

# ğŸŸ© Comment Ã§a marche ?

### ğŸ”¸ Lors de la connexion

- PHP vÃ©rifie le duo `admin / 1234`

- Si OK â†’ il place `auth_user=admin` dans un cookie

### ğŸ”¸ Ã€ la visite de dashboard.php

- Le script vÃ©rifie si `$_COOKIE["auth_user"]` existe

- Si oui â†’ accÃ¨s autorisÃ©

- Sinon â†’ redirection vers login.php

### ğŸ”¸ Lors de la dÃ©connexion

- On supprime le cookie en mettant une date expirÃ©e

---

# ğŸŸ¥ Limites (important)

Cet exemple est **purement dÃ©mo**.  
Il manque :

- pas de hachage de mot de passe

- pas de token sÃ©curisÃ©

- cookie modifiable par lâ€™utilisateur

â¡ï¸ Nâ€™importe qui peut crÃ©er manuellement un cookie `auth_user=admin`.

Voici un **miniâ€“cas pÃ©dagogique trÃ¨s simple**, parfaitement adaptÃ© pour vos ateliers :  
un client â†’ envoie un **header** â†’ lâ€™API PHP vÃ©rifie â†’ rÃ©ponse OK ou KO â†’ redirection.

Tout est minimaliste, clair, prÃªt Ã  tester dans un serveur local.

---

# Cas 3: Utilisation des headers dans les sessions

Un **header** (en-tÃªte HTTP) est une information envoyÃ©e dans la requÃªte ou la rÃ©ponse HTTP.  
Il sert Ã  transmettre des mÃ©tadonnÃ©es comme :

- type de contenu (`Content-Type`),

- cookies (`Set-Cookie`),

- autorisation (`Authorization`),

- redirections (`Location`).

Dans ce cas, nous allons envoyer un header personnalisÃ© :

```
X-Auth: 12345
```

Lâ€™API va vÃ©rifier cette valeur.

---

# ğŸ”¹ ğŸ”§ Structure du mini-cas

```
mini-demo/
â”‚
â”œâ”€â”€ client.html          # Page du client (envoie une requÃªte + header)
â”œâ”€â”€ api.php              # API PHP : vÃ©rifie le header
â””â”€â”€ error.php            # Page affichÃ©e si Ã©chec
```

---

# ğŸ”¹ 1) Page client (envoi dâ€™un header + affichage du rÃ©sultat)

CrÃ©er le fichier **client.html** :

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Client â†’ API</title>
</head>
<body>

<h2>Test communication Client â†’ API</h2>

<button id="callApi">Appeler l'API</button>

<p id="result"></p>

<script>
// Quand on clique, on appelle l'API avec un header
document.getElementById('callApi').addEventListener('click', () => {

    fetch("api.php", {
        method: "GET",
        headers: {
            "X-Auth": "12345"   // ğŸ‘‰ Header envoyÃ© au serveur
        }
    })
    .then(response => response.json())
    .then(data => {
        document.getElementById('result').innerText = data.message;
    })
    .catch(() => {
        window.location.href = "error.php"; // redirection en cas dâ€™erreur fetch
    });
});
</script>

</body>
</html>
```

**Commentaires importants :**

- `fetch()` envoie un header `X-Auth`

- la rÃ©ponse JSON affichera "OK" ou entraÃ®nera une redirection cÃ´tÃ© JS

---

# ğŸ”¹ 2) API PHP (vÃ©rification du header)

CrÃ©er le fichier **api.php** :

```php
<?php
header("Content-Type: application/json; charset=utf-8");

// On rÃ©cupÃ¨re tous les headers envoyÃ©s par le client
$headers = getallheaders();

// VÃ©rification du header X-Auth
if (!isset($headers['X-Auth']) || $headers['X-Auth'] !== "12345") {
    // Mauvaise clÃ© â†’ Ã©chec
    echo json_encode(["message" => "AccÃ¨s refusÃ©"]);
    exit;
}

// Si la clÃ© est correcte
echo json_encode(["message" => "AccÃ¨s autorisÃ©"]);
```

**Explication concise :**

- Nous lisons les headers avec `getallheaders()`

- Si `X-Auth` nâ€™existe pas ou nâ€™est pas correct â†’ rÃ©ponse nÃ©gative

- Sinon â†’ rÃ©ponse positive

---

# ğŸ”¹ 3) Page erreur

CrÃ©er le fichier **error.php** :

```php
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Erreur</title>
</head>
<body>

<h2>Erreur : Authentification refusÃ©e</h2>
<p>Le header fourni est invalide ou absent.</p>

</body>
</html>
```

---

# âœ”ï¸ Fonctionnement attendu

### ğŸ”¸ Cas 1 : header correct

- Le client envoie `X-Auth: 12345`

- `api.php` rÃ©pond :
  
  ```json
  { "message": "AccÃ¨s autorisÃ©" }
  ```

- affichage dans la page client â†’ "AccÃ¨s autorisÃ©"

### ğŸ”¸ Cas 2 : header incorrect ou absent

- Lâ€™API rÃ©pond :
  
  ```json
  { "message": "AccÃ¨s refusÃ©" }
  ```

- JS redirige vers `error.php`

## Cas 3 La protection avec CORS





# 

**CORS (Cross-Origin Resource Sharing)** = un mÃ©canisme de sÃ©curitÃ© du navigateur.

Il empÃªche une page web situÃ©e sur un domaine X dâ€™appeler un service Web situÃ© sur un domaine Y **si le serveur nâ€™autorise pas explicitement cette origine**.

Exemple :

- Front-end : `http://localhost/client/`

- API PHP : `http://localhost:8080/api/`

Le navigateur compare les origines : elles sont diffÃ©rentes â†’ bloque la requÃªte, **sauf** si lâ€™API PHP ajoute ce header :

```php
Access-Control-Allow-Origin: http://localhost
```

---

# ğŸŸ¦ 2. Structure simple du projet (3 fichiers)

```
cors-demo/
â”‚
â”œâ”€â”€ client.html           â†’ Page qui fait l'appel AJAX
â”œâ”€â”€ api.php               â†’ Service Web PHP qui rÃ©pond avec ou sans CORS
â””â”€â”€ error.html            â†’ Page affichÃ©e si CORS refuse
```

---

# ğŸŸ¦ 3. Contenu des fichiers

## âœ”ï¸ CrÃ©er le fichier **api.php**

```php
<?php
// Autoriser uniquement les requÃªtes venant de http://localhost
header("Access-Control-Allow-Origin: http://localhost");

// Autoriser la mÃ©thode GET
header("Access-Control-Allow-Methods: GET, OPTIONS");

// PrÃ©flight request (OPTIONS)
if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {
    http_response_code(200);
    exit();
}

echo json_encode(["status" => "ok", "message" => "CORS validÃ©, accÃ¨s autorisÃ©"]);
```

### ğŸ” Explication

- Le serveur PHP autorise **uniquement** lâ€™origine `http://localhost`

- Si la requÃªte vient dâ€™ailleurs (ex : `http://127.0.0.1:5500`), le navigateur bloque â†’ redirection cÃ´tÃ© client

---

## âœ”ï¸ CrÃ©er le fichier **client.html**

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Test CORS</title>
</head>
<body>

<h1>Test CORS vers API PHP</h1>

<button onclick="testerCORS()">Tester</button>

<script>
function testerCORS() {
    fetch("http://localhost:8080/api.php")
        .then(response => {
            if (!response.ok) {
                // Lâ€™API refuse ou CORS bloque â†’ redirection
                window.location.href = "error.html";
                return;
            }

            return response.json();
        })
        .then(data => {
            if (data) {
                alert("SuccÃ¨s : " + data.message);
            }
        })
        .catch(() => {
            // Erreur typique CORS â†’ redirection
            window.location.href = "error.html";
        });
}
</script>

</body>
</html>
```

### ğŸ” Explication

- Le bouton lance un `fetch()` vers lâ€™API PHP

- Si CORS bloque â†’ aucune rÃ©ponse = erreur â†’ redirection vers **error.html**

- Si CORS OK â†’ affiche lâ€™alerte "SuccÃ¨s"

---

## âœ”ï¸ CrÃ©er le fichier **error.html**

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Erreur CORS</title>
</head>
<body>

<h1 style="color:red;">AccÃ¨s refusÃ© : CORS non autorisÃ©</h1>

<p>Votre origine n'est pas autorisÃ©e par le serveur PHP.</p>

</body>
</html>
```

---

# ğŸŸ¦ 4. Test du fonctionnement

## ğŸ”¹ Cas 1 : Lâ€™origine est autorisÃ©e

Si vous ouvrez `client.html` via `http://localhost/client.html`  
â†’ CORS OK â†’ alert "SuccÃ¨s"

## ğŸ”¹ Cas 2 : Lâ€™origine est interdite

Si vous ouvrez `client.html` via un autre port (ex : Live Server : `http://127.0.0.1:5500`)  
â†’ CORS KO â†’ fetch bloquÃ© â†’ redirection automatique vers **error.html**

---

# ğŸŸ¦ 5. RÃ©sumÃ© final

CORS = un mÃ©canisme du navigateur, pas du PHP  
â†’ mais câ€™est PHP qui envoie les headers qui permettent ou non l'accÃ¨s.

Cet exemple :

- Introduit CORS simplement

- Montre une interaction minimale client â†’ API

- GÃ¨re le cas acceptÃ©

- GÃ¨re le cas refusÃ© + redirection



## Cas 4 Authentification via JWT Token

## 1. Contexte & objectif de lâ€™atelier

### Contexte

- Vous avez un environnement PHP (Windows ou Linux, peu importe).

- Vous voulez montrer Ã  des dÃ©butants **comment fonctionne un service web avec JWT** :
  
  - une route `/login.php` qui retourne un token JWT si les identifiants sont corrects,
  
  - une route protÃ©gÃ©e `/me.php` qui nâ€™est accessible que si le client envoie un **header Authorization: Bearer `.

- Les tests se feront **uniquement avec Postman**, plus accessible que `curl` pour les dÃ©butants.

### Objectifs pÃ©dagogiques

Ã€ la fin de lâ€™atelier, le participant doit Ãªtre capable de :

1. Expliquer briÃ¨vement ce quâ€™est un **JWT** et dans quel contexte on lâ€™utilise.

2. Comprendre comment **gÃ©nÃ©rer un JWT en PHP natif** (sans Composer et sans librairie externe).

3. Comprendre comment **vÃ©rifier un JWT** cÃ´tÃ© serveur.

4. Utiliser **Postman** pour :
   
   - appeler `/login.php` avec un body JSON,
   
   - rÃ©cupÃ©rer le token JWT,
   
   - lâ€™envoyer ensuite dans un header `Authorization` Ã  `/me.php`.

---

## 2. PrÃ©paration de lâ€™environnement

### PrÃ©requis

- PHP â‰¥ 8 installÃ© (par ex. `C:\phpsource\php` ou autre).

- Un dossier de projet accessible par serveur web :
  
  - soit via Apache / Nginx / MAMP / XAMPP,
  
  - soit via le serveur interne de PHP : `php -S localhost:8000`.

- **Postman** installÃ© (desktop app).

### Structure du projet

Nous allons crÃ©er un dossier `jwt-demo` avec les fichiers suivants :

```
jwt-demo/
â”‚
â”œâ”€â”€ config.php      # config globale + fonction utilitaire pour JSON
â”œâ”€â”€ jwt.php         # fonctions pour crÃ©er et vÃ©rifier un JWT
â”œâ”€â”€ login.php       # endpoint de login : gÃ©nÃ¨re un token JWT
â””â”€â”€ me.php          # endpoint protÃ©gÃ©, nÃ©cessite un JWT valide
```

Placez `jwt-demo` :

- soit dans le rÃ©pertoire racine de votre serveur web (ex : `C:\Apache24\htdocs\jwt-demo`),

- soit dans un dossier de travail si vous utilisez `php -S`.

---

## 3. Ã‰tapes dâ€™exÃ©cution dÃ©taillÃ©es

### Ã‰tape 1 â€“ CrÃ©er le fichier de configuration `config.php`

**RÃ´le :**

- Centraliser la **clÃ© secrÃ¨te** utilisÃ©e pour signer les JWT.

- Fournir une fonction `json_response()` pour envoyer des rÃ©ponses JSON propres.

CrÃ©er le fichier **config.php** :

```php
<?php
// config.php
// Fichier de configuration simple pour le mini service web JWT

// ClÃ© secrÃ¨te utilisÃ©e pour signer les JWT.
// âš  En production : clÃ© beaucoup plus longue, stockÃ©e dans une variable d'environnement.
const JWT_SECRET = 'ma_cle_secrete_tres_simple';

// Fonction utilitaire pour envoyer une rÃ©ponse JSON propre au client.
function json_response(array $data, int $statusCode = 200): void
{
    // DÃ©finir le code HTTP de la rÃ©ponse (200, 400, 401, 500, etc.)
    http_response_code($statusCode);

    // PrÃ©ciser que le contenu renvoyÃ© est du JSON en UTF-8
    header('Content-Type: application/json; charset=utf-8');

    // Encoder le tableau PHP en JSON et l'envoyer au client
    echo json_encode($data);

    // ArrÃªter le script immÃ©diatement aprÃ¨s la rÃ©ponse
    exit;
}
```

---

### Ã‰tape 2 â€“ CrÃ©er le fichier `jwt.php` (fonctions JWT)

**RÃ´le :**

- Fournir :
  
  - `create_jwt(array $payload): string` â†’ gÃ©nÃ¨re un token JWT signÃ©.
  
  - `verify_jwt(string $token): ?array` â†’ vÃ©rifie le token et retourne les donnÃ©es (payload) ou `null`.

CrÃ©er le fichier **jwt.php** :

```php
<?php
// jwt.php
// Fonctions minimalistes pour crÃ©er et vÃ©rifier un JWT sans librairie externe.

require_once __DIR__ . '/config.php';

// Encodage en base64url : variante base64 adaptÃ©e aux URLs (sans +, /, =)
function base64url_encode(string $data): string
{
    // base64_encode standard
    $base64 = base64_encode($data);

    // Remplacer les caractÃ¨res non adaptÃ©s aux URLs et supprimer les '=' finaux
    return rtrim(strtr($base64, '+/', '-_'), '=');
}

// DÃ©codage en base64url : opÃ©ration inverse de base64url_encode
function base64url_decode(string $data): string
{
    // Remettre les caractÃ¨res de base64 standard
    $base64 = strtr($data, '-_', '+/');

    // Ajouter les '=' manquants si nÃ©cessaire
    $padLen = 4 - (strlen($base64) % 4);
    if ($padLen < 4) {
        $base64 .= str_repeat('=', $padLen);
    }

    // DÃ©coder en binaire
    return base64_decode($base64);
}

// CrÃ©ation d'un JWT signÃ© avec l'algorithme HS256
function create_jwt(array $payload): string
{
    // Header du JWT : type du token (JWT) + algorithme de signature (HS256)
    $header = [
        'typ' => 'JWT',
        'alg' => 'HS256',
    ];

    // Encoder header et payload en JSON puis en base64url
    $headerEncoded  = base64url_encode(json_encode($header));
    $payloadEncoded = base64url_encode(json_encode($payload));

    // Construire la chaÃ®ne Ã  signer : "header.payload"
    $dataToSign = $headerEncoded . '.' . $payloadEncoded;

    // Signature HMAC-SHA256 avec la clÃ© secrÃ¨te
    $signature = hash_hmac(
        'sha256',
        $dataToSign,
        JWT_SECRET,
        true // true = sortie binaire (non hexadÃ©cimale)
    );

    // Encodage de la signature en base64url
    $signatureEncoded = base64url_encode($signature);

    // Token final : "header.payload.signature"
    return $headerEncoded . '.' . $payloadEncoded . '.' . $signatureEncoded;
}

// VÃ©rification d'un JWT : retourne le payload (tableau) ou null si invalide
function verify_jwt(string $token): ?array
{
    // DÃ©couper le token en 3 parties sÃ©parÃ©es par des points
    $parts = explode('.', $token);
    if (count($parts) !== 3) {
        // Mauvais format de token
        return null;
    }

    [$headerEncoded, $payloadEncoded, $signatureEncoded] = $parts;

    // Recalculer la signature attendue Ã  partir du header et du payload
    $dataToSign = $headerEncoded . '.' . $payloadEncoded;

    $expectedSignature = base64url_encode(
        hash_hmac(
            'sha256',
            $dataToSign,
            JWT_SECRET,
            true
        )
    );

    // Comparer la signature envoyÃ©e avec la signature recalculÃ©e
    if (!hash_equals($expectedSignature, $signatureEncoded)) {
        // Signature invalide â†’ token falsifiÃ© ou clÃ© incorrecte
        return null;
    }

    // DÃ©coder le payload JSON
    $payloadJson = base64url_decode($payloadEncoded);
    $payload = json_decode($payloadJson, true);

    // Si on n'obtient pas un tableau, le token est invalide
    if (!is_array($payload)) {
        return null;
    }

    // VÃ©rifier la date d'expiration (champ "exp") si prÃ©sente
    if (isset($payload['exp']) && time() > $payload['exp']) {
        // Token expirÃ©
        return null;
    }

    // Si tout est bon, on retourne le payload (donnÃ©es du token)
    return $payload;
}
```

---

### Ã‰tape 3 â€“ CrÃ©er lâ€™endpoint `login.php` (gÃ©nÃ¨re un JWT)

**RÃ´le :**

- Recevoir un JSON avec `username` et `password` (via POST).

- VÃ©rifier les identifiants (en dur pour la dÃ©mo).

- GÃ©nÃ©rer un JWT avec `create_jwt()`.

- Retourner le JWT au client.

CrÃ©er le fichier **login.php** :

```php
<?php
// login.php
// Endpoint de connexion : renvoie un token JWT si les identifiants sont corrects.

require_once __DIR__ . '/config.php';
require_once __DIR__ . '/jwt.php';

// On n'accepte que la mÃ©thode HTTP POST pour ce endpoint
if ($_SERVER['REQUEST_METHOD'] !== 'POST') {
    json_response(['error' => 'MÃ©thode non autorisÃ©e. Utiliser POST.'], 405);
}

// RÃ©cupÃ©rer le corps brut de la requÃªte (JSON)
$rawBody = file_get_contents('php://input');

// DÃ©coder le JSON en tableau PHP associatif
$data = json_decode($rawBody, true);

// Extraire username et password (ou null s'ils n'existent pas)
$username = $data['username'] ?? null;
$password = $data['password'] ?? null;

// VÃ©rification minimale des champs requis
if ($username === null || $password === null) {
    json_response(['error' => 'Champs "username" et "password" requis.'], 400);
}

// Pour la dÃ©mo : identifiants codÃ©s en dur.
// En production : comparaison avec une base de donnÃ©es + password hash.
if ($username !== 'admin' || $password !== 'secret') {
    json_response(['error' => 'Identifiants invalides.'], 401);
}

// Construire le payload du token JWT
$payload = [
    'sub' => $username,          // "subject" = identifiant de l'utilisateur
    'role' => 'admin_demo',      // Exemple de rÃ´le
    'iat' => time(),             // "issued at" = date de crÃ©ation du token
    'exp' => time() + 3600,      // "expiration" = maintenant + 3600 secondes (1h)
];

// CrÃ©ation du token JWT
$token = create_jwt($payload);

// Retourner une rÃ©ponse JSON avec le token
json_response([
    'message' => 'Connexion rÃ©ussie.',
    'token'   => $token,
]);
```

---

### Ã‰tape 4 â€“ CrÃ©er lâ€™endpoint protÃ©gÃ© `me.php`

**RÃ´le :**

- Lire le header `Authorization: Bearer <token>`.

- VÃ©rifier le token via `verify_jwt()`.

- Si valide â†’ retourner les infos de lâ€™utilisateur.

- Si invalide â†’ renvoyer une erreur 401.

CrÃ©er le fichier **me.php** :

```php
<?php
// me.php
// Endpoint protÃ©gÃ© par JWT : nÃ©cessite un header Authorization: Bearer <token>

require_once __DIR__ . '/config.php';
require_once __DIR__ . '/jwt.php';

// RÃ©cupÃ©rer tous les en-tÃªtes HTTP de la requÃªte
$headers = getallheaders();

// RÃ©cupÃ©rer le header Authorization s'il existe
$authHeader = $headers['Authorization'] ?? '';

// VÃ©rifier que le header commence par "Bearer "
// str_starts_with est disponible Ã  partir de PHP 8.
if (!str_starts_with($authHeader, 'Bearer ')) {
    json_response(['error' => 'Header Authorization Bearer manquant ou incorrect.'], 401);
}

// Extraire le token JWT aprÃ¨s le mot "Bearer "
$token = trim(substr($authHeader, 7));

// VÃ©rifier le token avec notre fonction utilitaire
$payload = verify_jwt($token);

// Si la vÃ©rification Ã©choue, renvoyer une erreur 401
if ($payload === null) {
    json_response(['error' => 'Token invalide ou expirÃ©.'], 401);
}

// Si on arrive ici, le token est valide.
// On renvoie les informations contenues dans le payload.
json_response([
    'message' => 'AccÃ¨s autorisÃ©.',
    'user'    => [
        'username' => $payload['sub'] ?? null,
        'role'     => $payload['role'] ?? null,
        'exp'      => $payload['exp'] ?? null,
    ],
]);
```

---

### Ã‰tape 5 â€“ Lancer le serveur PHP

#### Option A â€“ Serveur interne PHP (simple pour dÃ©mo)

Dans un terminal positionnÃ© dans le dossier parent de `jwt-demo` :

```bash
php -S localhost:8000
```

Cela rendra votre projet accessible Ã  lâ€™adresse :

- `http://localhost:8000/jwt-demo/login.php`

- `http://localhost:8000/jwt-demo/me.php`

*(adapter si votre arborescence diffÃ¨re)*

#### Option B â€“ Apache / MAMP / XAMPP

- Placez le dossier `jwt-demo` dans `htdocs` ou `www`, par ex. `C:\Apache24\htdocs\jwt-demo`.

- AccÃ©dez ensuite Ã  :
  
  - `http://localhost/jwt-demo/login.php`
  
  - `http://localhost/jwt-demo/me.php`

---

### Ã‰tape 6 â€“ Tests complets avec Postman

#### 6.1. Tester `/login.php` (obtenir un token JWT)

1. Ouvrir Postman.

2. Cliquer sur **New â†’ HTTP Request**.

3. MÃ©thode : **POST**.

4. URL (adapter selon votre cas) :
   
   - Avec serveur interne PHP :  
     `http://localhost:8000/jwt-demo/login.php`
   
   - Avec Apache :  
     `http://localhost/jwt-demo/login.php`

5. Onglet **Body** :
   
   - SÃ©lectionner **raw**.
   
   - Type : **JSON**.
   
   - Mettre ce contenu :

```json
{
  "username": "admin",
  "password": "secret"
}
```

6. Cliquer sur **Send**.

**RÃ©sultat attendu :**

```json
{
  "message": "Connexion rÃ©ussie.",
  "token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9..."
}
```

â¡ï¸ Copier la valeur du champ `token` (entiÃ¨re).

---

#### 6.2. Tester `/me.php` (endpoint protÃ©gÃ©)

1. CrÃ©er une nouvelle requÃªte dans Postman (ou dupliquer la prÃ©cÃ©dente).

2. MÃ©thode : **GET**.

3. URL :
   
   - Avec serveur interne PHP :  
     `http://localhost:8000/jwt-demo/me.php`
   
   - Avec Apache :  
     `http://localhost/jwt-demo/me.php`

4. Aller dans lâ€™onglet **Headers**.

5. Ajouter une ligne :
   
   | Key           | Value                        |
   | ------------- | ---------------------------- |
   | Authorization | Bearer VOTRE_TOKEN_COPIÃ‰_ICI |
   
   Exemple :
   
   ```
   Authorization : Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...
   ```

6. Cliquer sur **Send**.

**RÃ©sultat attendu (token valide) :**

```json
{
  "message": "AccÃ¨s autorisÃ©.",
  "user": {
    "username": "admin",
    "role": "admin_demo",
    "exp": 1731600000
  }
}
```

---

#### 6.3. Tester les cas dâ€™erreur (pour la pÃ©dagogie)

- **Sans header Authorization :**
  
  - Supprimer la ligne `Authorization` dans Postman.
  
  - RÃ©sultat attendu :
    
    ```json
    {
      "error": "Header Authorization Bearer manquant ou incorrect."
    }
    ```

- **Avec token bidon :**
  
  - Mettre : `Authorization: Bearer abc123`
  
  - RÃ©sultat :
    
    ```json
    {
      "error": "Token invalide ou expirÃ©."
    }
    ```

- **Avec mauvais identifiants sur /login.php :**
  
  - Changer `password` en `"wrong"`.
  
  - RÃ©sultat :
    
    ```json
    {
      "error": "Identifiants invalides."
    }
    ```

---

## 4. VÃ©rifications / RÃ©sultats attendus

Ã€ la fin de lâ€™atelier, vÃ©rifiez que les participants savent :

1. **Montrer le body JSON dans Postman** pour `/login.php`.

2. **Localiser le token dans la rÃ©ponse JSON**.

3. **CrÃ©er un header Authorization** dans Postman pour `/me.php`.

4. Expliquer en une phrase :
   
   - Ã  quoi sert `login.php`,
   
   - Ã  quoi sert `me.php`,
   
   - Ã  quoi sert le **header Authorization**.

---

## 5. Nettoyage / Rollback

Pour nettoyer lâ€™environnement aprÃ¨s la dÃ©monstration :

1. Supprimer le dossier `jwt-demo` si ce nâ€™est plus utile.

2. ArrÃªter le serveur intÃ©grÃ© PHP (`Ctrl + C` dans le terminal).

3. Ã‰ventuellement supprimer les requÃªtes Postman de test ou les archiver dans une collection â€œDÃ©mo JWTâ€.

---

## 6. Tips & piÃ¨ges Ã  Ã©viter

- **Ne jamais** exposer une clÃ© secrÃ¨te faible en production comme dans lâ€™exemple.

- Toujours utiliser **HTTPS** quand on joue avec des tokens.

- Ã‰viter `$_SESSION` pour une API REST â†’ privilÃ©gier des tokens stateless comme JWT.

- Bien insister auprÃ¨s des dÃ©butants sur le rÃ´le du header :
  
  > Le header `Authorization: Bearer <token>`  
  > est le â€œbadgeâ€ que le client prÃ©sente Ã  chaque requÃªte pour prouver son identitÃ©.

---

Si tu veux, on pourra faire tout de suite **une V2 de cet atelier** :

- en remplaÃ§ant les identifiants en dur par une vraie table MySQL `users`,

- ou en ajoutant un **refresh token** pour une dÃ©mo plus avancÃ©e.
