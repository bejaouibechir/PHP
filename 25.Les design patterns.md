# Patterns de conception PHP

**Les modÃ¨les de conception** sont des **solutions rÃ©utilisables** qui servent de modÃ¨les Ã©prouvÃ©s pour rÃ©soudre des **problÃ¨mes courants** en dÃ©veloppement logiciel.

ğŸ¯ **En PHP**, on peut implÃ©menter efficacement la plupart de ces patterns standards pour crÃ©er des applications robustes et maintenables.

---

### ğŸ­ **Le ModÃ¨le Singleton**

ğŸ›¡ï¸ **Une seule instance** - Restreint l'instanciation d'une classe Ã  une **unique instance**

ğŸŒ **AccÃ¨s global** - Offre un point d'accÃ¨s unique Ã  travers toute l'application

ğŸ’¡ **Application typique** : La crÃ©ation d'un objet de **connexion Ã  la base de donnÃ©es**, qui doit Ãªtre **unique** pendant toute la durÃ©e de vie de l'application.

---

**Exemple concret** : La classe `DataBaseConnector` ne peut Ãªtre instanciÃ©e qu'**une seule fois**. Toute tentative de duplication dÃ©clenchera un message d'erreur interdisant les objets dupliquÃ©s.

```php
<?php
   class DataBaseConnector {                
      private static $obj;                
      private final function __construct() {
         echo __CLASS__ . " object created for first time ". PHP_EOL;
      }
      public static function getConnect() {
         if (!isset(self::$obj)) {
            self::$obj = new DataBaseConnector();
            return self::$obj;
         } else {
            echo "connection object could not be created again" . PHP_EOL;
         }
      }
   }

   $obj1 = DataBaseConnector::getConnect();
   $obj2 = DataBaseConnector::getConnect();

   var_dump($obj1 == $obj2);
?>
```

Il produira la sortie suivante:

```bash
DataBaseConnector object created for first time 
connection object could not be created again
bool(false)
```

## ModÃ¨le d'usine Factory

C'est l'un des modÃ¨les **les plus couramment utilisÃ©s** dans le dÃ©veloppement logiciel.

**ğŸ¯ Le principe clÃ© :**  
Au lieu de crÃ©er directement un objet avec `new MaClasse()`, on passe par une **classe factory** dont la mÃ©thode statique se charge de la crÃ©ation de l'objet requis.

**ğŸ’¡ Pourquoi cette approche ?**

- **Encapsulation** de la logique de crÃ©ation

- **FlexibilitÃ©** pour changer le type d'objet crÃ©Ã©

- **Centralisation** du code d'instanciation

L'exemple suivant montre comment fonctionne le modÃ¨le de conception d'usine -

```php
<?php
   class Automobile {
      private $bikeMake;
      private $bikeModel;

      public function __construct($make, $model) {
         $this->bikeMake = $make;
         $this->bikeModel = $model;
      }

      public function getMakeAndModel() {
         return $this->bikeMake . ' ' . $this->bikeModel;
      }
   }

   class AutomobileFactory {
      public static function create($make, $model) {
         return new Automobile($make, $model);
      }
   }

   $pulsar = AutomobileFactory::create('ktm', 'Pulsar');
   print_r($pulsar->getMakeAndModel());
?>
```

Il produira la sortie suivante:

```
ktm Pulsar
```

## ModÃ¨le de stratÃ©gie

**Le ModÃ¨le StratÃ©gie (Strategy Pattern)**

**ğŸ’¡ Le concept clÃ© :**  
Encapsulez des **familles d'algorithmes** spÃ©cifiques, permettant Ã  la classe cliente d'**injecter dynamiquement** l'algorithme souhaitÃ©.

**ğŸ” Le principe fondamental :**  
La classe principale n'a **aucune connaissance** de l'implÃ©mentation rÃ©elle des algorithmes - elle dÃ©lague complÃ¨tement le comportement.

Voici un code qui dÃ©montre l'utilisation du modÃ¨le de stratÃ©gie.

```php
<?php
   interface example {
      public function case($str);
   }

   class ucase implements example {
      public function case($str) {
         return strtoupper($str);
      } 
   }

   class lcase implements example {
      public function case($str) {
         return strtolower($str);
      }
   }

   class testdata {
      private $data;

      public function __construct($input) {
         $this->data = $input;
      }
      public function process(example $type) {
         return $this->data = $type->case($this->data);
      }
   }
   $str = "hello";
   $obj = new testdata($str);
   echo $obj->process(new ucase) . PHP_EOL;  
   $str = "HELLO";
   echo $obj->process(new lcase);
?>
```

Il produira la sortie suivante:

```bash
HELLO
Hello
```

# 
