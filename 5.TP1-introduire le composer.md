# üéì TP1 ‚Äî Composer : comprendre avant d‚Äôutiliser

---

## üéØ Objectif du TP

D√©couvrir **Composer**, comprendre **pourquoi** il est indispensable dans l'√©cosyst√®me PHP moderne,  
et apprendre √† **l'installer, le tester et le manipuler** √† travers un mini-projet simple.

---

## üß≠ Contexte

Avant Composer, le d√©veloppement PHP ressemblait √† un atelier sans bo√Æte √† outils partag√©e.  
Chaque d√©veloppeur :

- t√©l√©chargeait manuellement les biblioth√®ques,

- g√©rait les versions √† la main,

- et devait inclure chaque fichier avec des `require` manuels.

üëâ R√©sultat : du code difficile √† maintenir, √† partager, et souvent cass√© d√®s qu'on changeait de version.

---

## üí° Introduction √† Composer

**Composer** est le **gestionnaire de d√©pendances officiel de PHP**.  
Son r√¥le est de **faire pour PHP ce que npm fait pour Node.js ou pip pour Python** :

| Probl√®me d'avant                        | Solution avec Composer                            |
| --------------------------------------- | ------------------------------------------------- |
| Fichiers inclus manuellement            | Chargement automatique (autoload)                 |
| Versions incompatibles                  | Gestion centralis√©e des versions                  |
| Difficult√© √† partager un projet         | Fichier `composer.json` d√©crivant tout le projet  |
| Installation manuelle des biblioth√®ques | T√©l√©chargement automatique via `composer install` |

**En r√©sum√© :** Composer permet √† PHP de travailler "en √©quipe" avec d'autres biblioth√®ques sans friction.

---

## ‚öôÔ∏è √âtape 1 ‚Äì V√©rifier votre environnement PHP

Ouvrez un terminal et tapez :

```bash
php --version
```

‚úÖ Si vous voyez une version 8.x ou sup√©rieure, tout va bien.  
Sinon, installez ou mettez √† jour PHP avant de continuer.

üí¨ **Pourquoi v√©rifier √ßa ?**  
Parce que Composer s'appuie sur PHP.  
S'il ne trouve pas le moteur PHP ou une version trop ancienne, il ne fonctionnera pas.

---

## ‚öôÔ∏è √âtape 2 ‚Äì Installer Composer

### üîπ Sur Windows

T√©l√©chargez le programme d'installation ici :  
üëâ [Composer](https://getcomposer.org/download/)

Puis ex√©cutez :

```bash
composer --version
```

### üîπ Alternative universelle (si la commande n'est pas reconnue)

Dans le terminal :

```bash
php -r "copy('https://getcomposer.org/installer', 'composer-setup.php');"
php composer-setup.php
php composer.phar --version
```

üí¨ **Pourquoi installer Composer ainsi ?**  
Parce que cette m√©thode fonctionne m√™me dans les environnements sans droits administratifs ou sur Linux.

---

On va construire un mini-projet √©tape par √©tape, exactement avec tes trois phases, pour bien sentir le r√¥le de Composer et de l‚Äôautoload.

Je vais supposer que tu as un dossier de travail, par exemple : `C:\php-projets\geometrie` (ou √©quivalent sous Linux).

---

## TP1: Structure globale du mini-projet

On va manipuler trois formes g√©om√©triques :

- `Triangle`

- `Rectangle`

- `Cercle`

Et un fichier `index.php` qui les utilise.

#### Phase 1 ‚Äì Sans autoload, avec `require_once` manuels

#### Phase 2 ‚Äì Avec un autoloader "maison" (`spl_autoload_register`)

#### Phase 3 ‚Äì Avec Composer et son autoload PSR-4

## Phase 1 ‚Äì Inclure les classes manuellement (`require_once`)

Objectif : montrer la mani√®re ‚Äúancienne‚Äù de faire, et pourquoi √ßa devient vite lourd.

### 1. Cr√©er les fichiers de classes

Cr√©er le fichier **Triangle.php** :

```php
<?php
// Classe Triangle : repr√©sente un triangle simple
class Triangle
{
    // Propri√©t√©s priv√©es pour la base et la hauteur
    private float $base;
    private float $hauteur;

    // Constructeur : initialise la base et la hauteur
    public function __construct(float $base, float $hauteur)
    {
        $this->base = $base;
        $this->hauteur = $hauteur;
    }

    // M√©thode pour calculer l'aire du triangle
    public function aire(): float
    {
        // Formule : (base * hauteur) / 2
        return ($this->base * $this->hauteur) / 2;
    }

    // M√©thode pour afficher une description textuelle
    public function description(): string
    {
        return "Triangle de base {$this->base} et hauteur {$this->hauteur}";
    }
}
```

Cr√©er le fichier **Rectangle.php** :

```php
<?php
// Classe Rectangle : repr√©sente un rectangle
class Rectangle
{
    // Propri√©t√©s priv√©es pour largeur et longueur
    private float $largeur;
    private float $longueur;

    // Constructeur : initialise largeur et longueur
    public function __construct(float $largeur, float $longueur)
    {
        $this->largeur = $largeur;
        $this->longueur = $longueur;
    }

    // M√©thode pour calculer l'aire du rectangle
    public function aire(): float
    {
        // Formule : largeur * longueur
        return $this->largeur * $this->longueur;
    }

    // M√©thode pour afficher une description textuelle
    public function description(): string
    {
        return "Rectangle de largeur {$this->largeur} et longueur {$this->longueur}";
    }
}
```

Cr√©er le fichier **Cercle.php** :

```php
<?php
// Classe Cercle : repr√©sente un cercle
class Cercle
{
    // Rayon du cercle
    private float $rayon;

    // Constructeur : initialise le rayon
    public function __construct(float $rayon)
    {
        $this->rayon = $rayon;
    }

    // M√©thode pour calculer l'aire du cercle
    public function aire(): float
    {
        // Formule : œÄ * r¬≤
        return pi() * $this->rayon * $this->rayon;
    }

    // M√©thode pour afficher une description textuelle
    public function description(): string
    {
        return "Cercle de rayon {$this->rayon}";
    }
}
```

### 2. Cr√©er `index.php` avec des `require_once`

Cr√©er le fichier **index.php** :

```php
<?php
// Phase 1 : on inclut chaque fichier de classe √† la main
// Ici, on suppose que les fichiers .php sont dans le m√™me dossier que index.php
require_once __DIR__ . '/Triangle.php';
require_once __DIR__ . '/Rectangle.php';
require_once __DIR__ . '/Cercle.php';

// On cr√©e quelques objets de nos classes
$triangle  = new Triangle(10, 5);
$rectangle = new Rectangle(4, 8);
$cercle    = new Cercle(3);

// On affiche des informations sur chaque forme
echo "<h1>D√©monstration Phase 1 - require_once</h1>";

echo "<p>{$triangle->description()} - Aire : " . $triangle->aire() . "</p>";
echo "<p>{$rectangle->description()} - Aire : " . $rectangle->aire() . "</p>";
echo "<p>{$cercle->description()} - Aire : " . $cercle->aire() . "</p>";

// Limites de cette approche :
// - √Ä chaque nouvelle classe, il faut penser √† ajouter un require_once.
// - Si on change de dossier, il faut modifier tous les chemins.
// - Sur un gros projet, on peut vite s'y perdre.
```

### 3. Ex√©cution

- Place tous les fichiers dans le m√™me dossier.

- Ex√©cute via ton serveur (MAMP, XAMPP, Apache perso, ou `php -S localhost:8000`).

- Ouvre `http://localhost/.../index.php`.

Tu verras les descriptions et les aires.

**Id√©e cl√©** : √ßa fonctionne, mais c‚Äôest manuel, fragile, et non scalable.

---

## Phase 2 ‚Äì Autoloader ‚Äúmaison‚Äù avec `spl_autoload_register`

Objectif : automatiser le chargement des classes sans avoir √† √©crire tous les `require_once`.

### 1. Cr√©er un autoloader simple

Ici, on va s‚Äôappuyer sur une convention tr√®s simple :

- Nom du fichier = Nom de la classe + `.php`
  
  - classe `Triangle` ‚Üí fichier `Triangle.php`
  
  - classe `Rectangle` ‚Üí fichier `Rectangle.php`
  
  - classe `Cercle` ‚Üí fichier `Cercle.php`

On garde les 3 fichiers de classes exactement comme en Phase 1.

On va seulement modifier `index.php` pour utiliser un autoloader.

Cr√©er le fichier **index.php** (version Phase 2, tu peux remplacer l‚Äôancien contenu) :

```php
<?php
// Phase 2 : Autoloader "maison" pour charger les classes automatiquement

// On enregistre une fonction d'autoload aupr√®s de PHP
spl_autoload_register(function (string $className) {

    $file = __DIR__ . '/' . $className . '.php';

    // On v√©rifie si le fichier existe avant de l'inclure
    if (file_exists($file)) {
        require_once $file;
    } else {
        // En environnement r√©el on loguerait l'erreur
        // Ici on affiche un message pour la p√©dagogie
        echo "<p style='color:red;'>Impossible de charger la classe {$className} (fichier {$file} introuvable)</p>";
    }
});

// √Ä partir de maintenant, on peut utiliser nos classes
// sans appeler require_once pour chaque fichier

$triangle  = new Triangle(10, 5);
$rectangle = new Rectangle(4, 8);
$cercle    = new Cercle(3);

echo "<h1>D√©monstration Phase 2 - Autoloader maison</h1>";

echo "<p>{$triangle->description()} - Aire : " . $triangle->aire() . "</p>";
echo "<p>{$rectangle->description()} - Aire : " . $rectangle->aire() . "</p>";
echo "<p>{$cercle->description()} - Aire : " . $cercle->aire() . "</p>";
```

**Id√©e cl√©** : on voit la notion d‚Äôautoloading, mais le m√©canisme est encore ‚Äúmaison‚Äù et tr√®s limit√©.

---

## Phase 3 ‚Äì Autoload avec Composer (PSR-4)

Objectif :

- D√©couvrir Composer comme gestionnaire de paquets **+** gestionnaire d‚Äôautoload.

- Introduire les namespaces et une structure plus propre (`src/`).

### 1. Pr√©parer une structure propre

On va r√©organiser le projet :

```
geometrie/
    src/
        Shapes/
            Triangle.php
            Rectangle.php
            Cercle.php
    public/
        index.php
    composer.json   (sera cr√©√© par Composer)
    vendor/         (sera g√©n√©r√© par Composer)
```

L‚Äôid√©e :

- `src/` contient TON code.

- `vendor/` contiendra le code des d√©pendances (biblioth√®ques externes).

- `public/` contient les points d‚Äôentr√©e (comme `index.php`).

### 2. D√©placer les fichiers de classes et les adapter

1. Cr√©e le dossier `src/Shapes`.

2. D√©place les 3 fichiers de classes dedans.

3. On va leur ajouter un namespace.

Cr√©er le fichier **src/Shapes/Triangle.php** :

```php
<?php
// Namespace : permet de regrouper logiquement les classes
// Ici, on place les formes dans App\Shapes
namespace App\Shapes;

// Classe Triangle : repr√©sente un triangle simple
class Triangle
{
    private float $base;
    private float $hauteur;

    public function __construct(float $base, float $hauteur)
    {
        $this->base = $base;
        $this->hauteur = $hauteur;
    }

    public function aire(): float
    {
        return ($this->base * $this->hauteur) / 2;
    }

    public function description(): string
    {
        return "Triangle de base {$this->base} et hauteur {$this->hauteur}";
    }
}
```

Cr√©er le fichier **src/Shapes/Rectangle.php** :

```php
<?php
namespace App\Shapes;

// Classe Rectangle : repr√©sente un rectangle
class Rectangle
{
    private float $largeur;
    private float $longueur;

    public function __construct(float $largeur, float $longueur)
    {
        $this->largeur  = $largeur;
        $this->longueur = $longueur;
    }

    public function aire(): float
    {
        return $this->largeur * $this->longueur;
    }

    public function description(): string
    {
        return "Rectangle de largeur {$this->largeur} et longueur {$this->longueur}";
    }
}
```

Cr√©er le fichier **src/Shapes/Cercle.php** :

```php
<?php
namespace App\Shapes;

// Classe Cercle : repr√©sente un cercle
class Cercle
{
    private float $rayon;

    public function __construct(float $rayon)
    {
        $this->rayon = $rayon;
    }

    public function aire(): float
    {
        return pi() * $this->rayon * $this->rayon;
    }

    public function description(): string
    {
        return "Cercle de rayon {$this->rayon}";
    }
}
```

### 3. Cr√©er `composer.json` pour d√©clarer l‚Äôautoload PSR-4

Dans le dossier racine du projet (`geometrie/`), on va configurer Composer.

Si Composer est install√©, tu peux soit faire un `composer init`, soit cr√©er le fichier √† la main. Pour la p√©dagogie, on va l‚Äô√©crire nous-m√™mes.

Cr√©er le fichier **composer.json** :

```json
{
    "name": "mon-vendor/geometrie",
    "description": "Mini projet de d√©monstration de l'autoload avec Composer",
    "type": "project",
    "autoload": {
        "psr-4": {
            "App\\": "src/"
        }
    },
    "require": {
    }
}
```

Commentaires :

- `"autoload"` ‚Üí section sp√©ciale qui dit √† Composer comment charger automatiquement nos classes.

- `"psr-4"` ‚Üí standard d‚Äôautoload moderne.

- `"App\\" : "src/"` ‚Üí signifie :
  
  - Tout ce qui commence par le namespace `App\` se trouve dans le dossier `src/`.
  
  - Exemple : `App\Shapes\Triangle` ‚Üí fichier `src/Shapes/Triangle.php`.

### 4. G√©n√©rer l‚Äôautoload de Composer

Dans un terminal, plac√© dans le dossier du projet (`geometrie/`), ex√©cute :

```bash
composer dump-autoload
```

- Cette commande lit `composer.json`.

- Elle g√©n√®re automatiquement les fichiers n√©cessaires dans `vendor/` pour l‚Äôautoload.

Apr√®s √ßa, tu auras un dossier `vendor/` avec entre autres un fichier `vendor/autoload.php`.

### 5. Cr√©er `public/index.php` pour utiliser l‚Äôautoload de Composer

Cr√©er le dossier `public` si ce n‚Äôest pas d√©j√† fait.  
Puis cr√©er le fichier **public/index.php** :

```php
<?php
// Phase 3 : Autoload via Composer

// On commence par inclure l'autoloader g√©n√©r√© par Composer.
// Ce fichier se trouve dans le dossier vendor.
require_once __DIR__ . '/../vendor/autoload.php';

// On importe les classes en utilisant leurs namespaces complets
use App\Shapes\Triangle;
use App\Shapes\Rectangle;
use App\Shapes\Cercle;

// On cr√©e des objets √† partir de nos classes
$triangle  = new Triangle(10, 5);
$rectangle = new Rectangle(4, 8);
$cercle    = new Cercle(3);

// On affiche les r√©sultats
echo "<h1>D√©monstration Phase 3 - Autoload avec Composer</h1>";

echo "<p>{$triangle->description()} - Aire : " . $triangle->aire() . "</p>";
echo "<p>{$rectangle->description()} - Aire : " . $rectangle->aire() . "</p>";
echo "<p>{$cercle->description()} - Aire : " . $cercle->aire() . "</p>";

// Avantages de l'autoload Composer :
// - Gestion automatique des namespaces et des dossiers.
// - Un standard largement utilis√© (PSR-4).
// - Tu peux ajouter des biblioth√®ques externes (Twig, Doctrine, etc.)
//   et Composer g√®re aussi leur autoload.
// - Sur des projets r√©els, tout le monde s'attend √† trouver un autoload
//   bas√© sur Composer.
```

### 6. Ex√©cution de la Phase 3

- Serveur web pointant sur le dossier `public` (MAMP, Apache, ou `php -S`).

- URL de type : `http://localhost/geometrie/public/index.php`.

Tu devrais voir le m√™me r√©sultat qu‚Äôen Phase 1 et 2‚Ä¶ mais cette fois :

- Pas de `require_once` pour chaque classe.

- Un autoload robuste, standard, extensible √† tous tes futurs projets.

- Pr√™t pour ajouter des **d√©pendances externes** (le vrai r√¥le principal de Composer).

---

## Synth√®se p√©dagogique

- **Phase 1 (require_once)** :  
  Tu fais tout √† la main ‚Üí √ßa marche pour un tout petit script, mais √ßa explose vite quand le projet grossit.

- **Phase 2 (autoloader maison)** :  
  Tu commences √† comprendre l‚Äôid√©e d‚Äôautoload ‚Üí PHP peut appeler une fonction quand une classe est utilis√©e.  
  Tu cr√©es ta propre logique de mapping classe ‚Üí fichier.

- **Phase 3 (Composer)** :  
  Tu arr√™tes de r√©inventer la roue ‚Üí tu utilises le standard PSR-4 via Composer.  
  Tu gagnes :
  
  - un autoload propre, bas√© sur namespaces + structure de dossiers,
  
  - la possibilit√© d‚Äôajouter facilement des biblioth√®ques externes (le c≈ìur de Composer),
  
  - une structure de projet professionnelle.

---

## üéØ TP2 : Gestionnaire de T√¢ches avec Validation d'Emails

### SC√âNARIO R√âEL :

Un formulaire de contact avec **validation d'emails** et **g√©n√©ration de mots de passe s√©curis√©s**.

---

## √âTAPE 1 : `composer.json`

Cr√©ez le fichier **avec le bloc de code exact** :

```json
{
    "require": {
        "egulias/email-validator": "^4.0",
        "fakerphp/faker": "^1.23"
    }
}
```

Executez 

```bash
composer install
```

La structure devrait √™tre: 

```bash
gestion-taches/
‚îú‚îÄ‚îÄ vendor/                 (g√©n√©r√© par Composer)
‚îú‚îÄ‚îÄ composer.json          (vos d√©pendances)
‚îú‚îÄ‚îÄ composer.lock         (g√©n√©r√© par Composer)
‚îî‚îÄ‚îÄ index.php             (votre application)
```

## √âTAPE 2 : `index.php`

Cr√©ez le fichier `index.php` **avec tout le code PHP/HTML exact** 

```php
<?php
require 'vendor/autoload.php';

use Egulias\EmailValidator\EmailValidator;
use Egulias\EmailValidator\Validation\RFCValidation;
use Faker\Factory;

$faker = Factory::create();
$validator = new EmailValidator();
$message = '';

// Traitement du formulaire
if ($_POST) {
    $email = $_POST['email'] ?? '';
    $nom = $_POST['nom'] ?? '';

    // VALIDATION AVEC LA LIBRAIRIE
    if ($validator->isValid($email, new RFCValidation())) {
        $message = "‚úÖ Email valide ! Un mot de passe s√©curis√© a √©t√© g√©n√©r√©.";
        $motdepasse = $faker->password(12, 20); // G√©n√©ration s√©curis√©e
    } else {
        $message = "‚ùå Email invalide ! Veuillez corriger.";
        $motdepasse = '';
    }
}
?>

<!DOCTYPE html>
<html>
<head>
    <title>Inscription - Validation Email</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 600px; margin: 40px auto; padding: 20px; }
        .form-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-weight: bold; }
        input[type="text"], input[type="email"] { 
            width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; 
        }
        button { 
            background: #4CAF50; color: white; padding: 12px 25px; 
            border: none; border-radius: 4px; cursor: pointer; 
        }
        .message { 
            padding: 15px; margin: 20px 0; border-radius: 4px; 
        }
        .success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .password { 
            background: #e9ecef; padding: 10px; margin: 10px 0; 
            font-family: monospace; font-size: 16px;
        }
    </style>
</head>
<body>
    <h1>üìù Formulaire d'Inscription</h1>
    <p>D√©monstration de <strong>validation d'email professionnelle</strong> et <strong>g√©n√©ration de mots de passe s√©curis√©s</strong> avec Composer.</p>

    <form method="post">
        <div class="form-group">
            <label for="nom">Nom complet :</label>
            <input type="text" id="nom" name="nom" value="<?= htmlspecialchars($_POST['nom'] ?? '') ?>" required>
        </div>

        <div class="form-group">
            <label for="email">Adresse email :</label>
            <input type="email" id="email" name="email" value="<?= htmlspecialchars($_POST['email'] ?? '') ?>" 
                   placeholder="exemple@domaine.com" required>
        </div>

        <button type="submit">Valider l'inscription</button>
    </form>

    <?php if ($message): ?>
        <div class="message <?= strpos($message, '‚úÖ') !== false ? 'success' : 'error' ?>">
            <h3>R√©sultat :</h3>
            <p><?= $message ?></p>

            <?php if ($motdepasse): ?>
                <div class="password">
                    <strong>Mot de passe g√©n√©r√© :</strong> <?= $motdepasse ?>
                </div>
                <p><small>üîí Ce mot de passe s√©curis√© a √©t√© g√©n√©r√© al√©atoirement avec FakerPHP</small></p>
            <?php endif; ?>
        </div>
    <?php endif; ?>

    <div style="margin-top: 30px; padding: 15px; background: #f8f9fa; border-radius: 4px;">
        <h3>üéØ Ce que Composer nous apporte :</h3>
        <ul>
            <li><strong>egulias/email-validator</strong> : Validation professionnelle des emails selon les normes RFC</li>
            <li><strong>fakerphp/faker</strong> : G√©n√©ration de donn√©es r√©alistes et s√©curis√©es</li>
            <li><strong>Gestion automatique</strong> des d√©pendances et autoloading</li>
        </ul>
    </div>
</body>
</html>
```

Dans le naviguateur http://localhost:8080/gestion-taches/index.php vous testez:

- Entrez un **email valide** : `test@example.com` ‚Üí ‚úÖ Succ√®s
- Entrez un **email invalide** : `test@` ‚Üí ‚ùå Erreur



# TP3: Modifier la source de composer



On va faire un **Atelier 3** tr√®s concret, centr√© sur **Monolog** et **Composer** :

1. D‚Äôabord : utilisation classique de Monolog via **Packagist**

2. Ensuite : on modifie `composer.json` pour que la **m√™me d√©pendance** soit r√©solue depuis **GitHub directement** (via un d√©p√¥t VCS).

Je pars sur un mini-projet simple, dans un dossier par exemple `C:\php-projets\monolog-demo` (ou √©quivalent Linux).

---

## üë£ √âtape 0 ‚Äì Structure simple du projet

On va viser cette structure :

```
monolog-demo/
    src/
        App.php
    public/
        index.php
    composer.json
    vendor/           (cr√©√© par Composer)
    logs/            (pour les fichiers de log)
```

---

## Phase A ‚Äì Utiliser Monolog via Packagist

### 1. Initialiser le projet avec Composer

Dans le dossier `monolog-demo` :

```bash
composer init
```

Tu peux r√©pondre rapidement aux questions, ou tout accepter par d√©faut.  
√Ä la fin, tu obtiens un fichier `composer.json` de base.

On va ensuite **installer Monolog** via Packagist :

```bash
composer require monolog/monolog
```

Composer va :

- Contacter **Packagist** (le d√©p√¥t par d√©faut des packages PHP)

- T√©l√©charger `monolog/monolog` dans `vendor/`

- G√©n√©rer / mettre √† jour `vendor/autoload.php`

- Mettre √† jour `composer.json` et `composer.lock`

### 2. Configurer l‚Äôautoload de ton code

On va d√©clarer un namespace `App\` qui pointe vers `src/`.

Ouvre `composer.json` et compl√®te la section `autoload` :

Cr√©er/modifier le fichier **composer.json** :

```json
{
    "name": "mon-vendor/monolog-demo",
    "description": "D√©monstration de Monolog avec Composer",
    "type": "project",
    "require": {
        "monolog/monolog": "^3.0"
    },
    "autoload": {
        "psr-4": {
            "App\\": "src/"
        }
    }
}
```

Ensuite, g√©n√®re l‚Äôautoload :

```bash
composer dump-autoload
```

### 3. Cr√©er une petite classe qui utilise Monolog

Cr√©er le dossier `src` puis le fichier **src/App.php** :

```php
<?php
namespace App;

use Monolog\Logger;
use Monolog\Handler\StreamHandler;

class App
{
    private Logger $logger;

    public function __construct()
    {
        // On cr√©e un logger nomm√© "app"
        $this->logger = new Logger('app');

        // On ajoute un handler qui √©crit dans logs/app.log au niveau INFO
        $this->logger->pushHandler(
            new StreamHandler(__DIR__ . '/../logs/app.log', Logger::INFO)
        );
    }

    public function run(): void
    {
        // Quelques logs de d√©monstration
        $this->logger->info('L\'application d√©marre');
        $this->logger->warning('Ceci est un message de warning');
        $this->logger->error('Ceci est un message d\'erreur simul√©');
    }
}
```

Cr√©er le dossier **logs** √† la racine du projet (pour les fichiers de log).

### 4. Cr√©er le point d‚Äôentr√©e `index.php`

Cr√©er le dossier `public` puis le fichier **public/index.php** :

```php
<?php
declare(strict_types=1);

require_once __DIR__ . '/../vendor/autoload.php';

use App\App;

$app = new App();
$app->run();

echo "<h1>Monolog - D√©monstration Packagist</h1>";
echo "<p>Des messages ont √©t√© √©crits dans le fichier <code>logs/app.log</code>.</p>";
```

### 5. Tester

Lance un serveur PHP interne dans le dossier `public` :

```bash
php -S localhost:8000
```

Puis ouvre `http://localhost:8000` dans le navigateur.

Ensuite, ouvre le fichier **logs/app.log** : tu dois voir les lignes de log g√©n√©r√©es par Monolog.

---

## Phase B ‚Äì Utiliser la m√™me d√©pendance via GitHub directement

Maintenant on garde **exactement le m√™me code PHP**, mais on change la mani√®re dont Composer r√©cup√®re `monolog/monolog`.

L‚Äôid√©e :

- Ajouter une section `"repositories"` dans `composer.json` pour pointer vers le **d√©p√¥t GitHub de Monolog**

- Forcer Composer √† utiliser ce d√©p√¥t VCS (Git) pour r√©soudre `monolog/monolog`.

### 1. Modifier `composer.json` pour ajouter le d√©p√¥t GitHub

On va dire √† Composer :

> Pour le package `monolog/monolog`, tu peux (ou dois) utiliser ce d√©p√¥t GitHub comme source.

Modifier le fichier **composer.json** :

```json
{
    "name": "mon-vendor/monolog-demo",
    "description": "D√©monstration de Monolog avec Composer via Packagist et GitHub",
    "type": "project",
    "require": {
        "monolog/monolog": "3.*"
    },
    "autoload": {
        "psr-4": {
            "App\\": "src/"
        }
    },
    "repositories": [
        {
            "type": "vcs",
            "url": "https://github.com/Seldaek/monolog"
        }
    ]
}
```

Points importants :

- `"type": "vcs"` ‚Üí on dit √† Composer que la source est un d√©p√¥t de contr√¥le de version (Git).

- `"url": "https://github.com/Seldaek/monolog"` ‚Üí d√©p√¥t officiel de Monolog.

- Le nom du package reste `monolog/monolog`.

### 2. Forcer Composer √† utiliser ce d√©p√¥t

Apr√®s modification de `composer.json`, ex√©cuter :

```bash
composer update monolog/monolog
```

Composer va :

- Lire la section `"repositories"`

- D√©couvrir que `monolog/monolog` existe comme d√©p√¥t Git VCS

- Cloner / utiliser ce d√©p√¥t comme source du package

- Mettre √† jour `vendor/monolog/monolog` en cons√©quence

Tu peux v√©rifier dans `composer.lock` que la source de Monolog pointe vers GitHub (VCS).

### 3. V√©rifier que tout fonctionne encore

On ne change **rien** au code PHP :

- `src/App.php` inchang√©

- `public/index.php` inchang√©

Relance le serveur si n√©cessaire :

```bash
php -S localhost:8000 -t public
```

Recharge la page dans le navigateur, puis consulte √† nouveau `logs/app.log`.

Si tout est correct :

- Les logs sont toujours g√©n√©r√©s,

- La seule chose qui a chang√© est **la provenance de la d√©pendance** (Packagist ‚Üí d√©p√¥t GitHub direct via VCS).

---

## R√©sum√© p√©dagogique du TP 3

1. **Composer + Packagist**
   
   - `composer require monolog/monolog`
   
   - Composer contacte Packagist, trouve le package, t√©l√©charge la version stable
   
   - Tu consommes la d√©pendance via `vendor/autoload.php`

2. **Composer + repositories + GitHub (VCS)**
   
   - Tu ajoutes une entr√©e `"repositories"` dans `composer.json`
   
   - Tu pointes vers `https://github.com/Seldaek/monolog`
   
   - `composer update monolog/monolog` re-r√©sout la d√©pendance depuis GitHub

3. **Code PHP identique**
   
   - C‚Äôest exactement le m√™me `use Monolog\Logger;` etc.
   
   - Seule la **source** du package a chang√©.

Si tu veux, on peut faire **une variante** de l‚Äôatelier o√π :

- On force une branche sp√©cifique ou un tag pr√©cis du repo GitHub

- On compare deux versions de Monolog (ex : v2 vs v3) avec le m√™me code

- Ou on ajoute **une deuxi√®me d√©pendance** (par ex. un formatteur JSON) pour enrichir la d√©mo.
