# Atelier PHP — Accès aux Bases de Données MySQL

## Objectifs Pédagogiques

**À la fin de cet atelier, vous saurez :**
- Comprendre les différences entre PDO et ORM
- Implémenter un CRUD complet avec PDO et requêtes préparées
- Découvrir Doctrine ORM et son fonctionnement
- Choisir la bonne approche selon votre projet
- Sécuriser vos applications contre les injections SQL et XSS

**Pourquoi c'est important ?**
La persistance des données est au cœur de toute application web moderne. Maîtriser l'accès aux bases de données est essentiel pour créer des applications robustes et sécurisées.

---

# Partie 1 : CRUD avec PDO (Approche Fondamentale)

## 1.1 Configuration de Base

### Contexte : Préparer l'environnement de travail

**Concept Clé :** PDO (PHP Data Objects) est une interface d'accès aux bases de données qui offre une couche d'abstraction et de sécurité.

**Fichier : `init.sql`**
```sql
-- Crée la base et la table de test
CREATE DATABASE IF NOT EXISTS demo_crud
  CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

USE demo_crud;

-- Table simple pour l'exemple
DROP TABLE IF EXISTS contacts;
CREATE TABLE contacts (
  id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  name VARCHAR(120) NOT NULL,
  email VARCHAR(190) NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Quelques données initiales
INSERT INTO contacts (name, email) VALUES
('Ada Lovelace', 'ada@example.com'),
('Alan Turing', 'alan@example.com');
```

**Fichier : `config.php`**
```php
<?php
/**
 * Configuration de connexion à MySQL
 * Pensez à adapter host/user/pass selon votre environnement
 */
const DB_HOST = '127.0.0.1';
const DB_NAME = 'demo_crud';
const DB_USER = 'root';
const DB_PASS = ''; // mettre votre mot de passe si nécessaire
```

---

## 1.2 Connexion Sécurisée avec PDO

### Contexte : Établir une connexion robuste et sécurisée

**Concept Clé :** Une connexion centralisée évite les duplications et assure une configuration cohérente.

**Fichier : `db.php`**
```php
<?php
/**
 * Fabrique de connexion PDO centralisée
 * Sécurité : 
 * - utf8mb4 pour un support Unicode complet
 * - ERRMODE_EXCEPTION pour capter proprement les erreurs SQL
 * - ATTR_EMULATE_PREPARES=false pour de "vraies" requêtes préparées
 */
require __DIR__ . '/config.php';

function pdo(): PDO {
    static $pdo = null; // Pattern Singleton : une seule instance
    if ($pdo === null) {
        $dsn = 'mysql:host=' . DB_HOST . ';dbname=' . DB_NAME . ';charset=utf8mb4';
        $pdo = new PDO($dsn, DB_USER, DB_PASS, [
            PDO::ATTR_ERRMODE            => PDO::ERRMODE_EXCEPTION,
            PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
            PDO::ATTR_EMULATE_PREPARES   => false, // Sécurité !
        ]);
    }
    return $pdo;
}

/**
 * Fonction de sécurité contre les attaques XSS
 */
function e(string $s): string {
    return htmlspecialchars($s, ENT_QUOTES | ENT_SUBSTITUTE, 'UTF-8');
}
```

**Points Clés :**
- `PDO::ERRMODE_EXCEPTION` : Transforme les erreurs SQL en exceptions PHP
- `PDO::FETCH_ASSOC` : Retourne les résultats sous forme de tableaux associatifs
- `ATTR_EMULATE_PREPARES` : Désactive l'émulation des requêtes préparées (plus sécurisé)

---

## 1.3 CRUD Complet avec PDO

### Contexte : Implémenter les 4 opérations fondamentales

**Concept Clé :** CRUD = Create, Read, Update, Delete - les opérations de base de toute application.

**Fichier : `index.php` (Create + Read)**
```php
<?php
/**
 * Page d'accueil : liste + formulaire d'ajout (Create + Read)
 * Sécurité:
 *  - Validation côté serveur (trim + vérif email)
 *  - Requêtes préparées pour éviter l'injection SQL
 *  - htmlspecialchars à l'affichage
 */
require __DIR__ . '/db.php';

$errors = [];

// CREATE - Traitement formulaire d'ajout
if ($_SERVER['REQUEST_METHOD'] === 'POST' && ($_POST['action'] ?? '') === 'create') {
    $name  = trim((string)($_POST['name']  ?? ''));
    $email = trim((string)($_POST['email'] ?? ''));

    // Validation
    if ($name === '') {
        $errors[] = "Le nom est obligatoire.";
    }
    if ($email === '' || !filter_var($email, FILTER_VALIDATE_EMAIL)) {
        $errors[] = "L'email est obligatoire et doit être valide.";
    }

    if (!$errors) {
        // REQUÊTE PRÉPARÉE : protection contre l'injection SQL
        $stmt = pdo()->prepare('INSERT INTO contacts (name, email) VALUES (?, ?)');
        $stmt->execute([$name, $email]);
        
        // Pattern PRG (Post/Redirect/Get) pour éviter le resoumis du formulaire
        header('Location: index.php?created=1');
        exit;
    }
}

// READ - Récupération de la liste
$contacts = pdo()->query('SELECT * FROM contacts ORDER BY created_at DESC')->fetchAll();
?>
<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>Contacts - CRUD PHP (PDO, sans ORM)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body { font-family:sans-serif; margin:2rem; }
    table { border-collapse:collapse; width:100%; margin-top:1rem; }
    th, td { border:1px solid #ddd; padding:.5rem; }
    form { display:grid; gap:.5rem; max-width:420px; margin-top:1rem; }
    .errors { background:#ffecec; color:#b00020; padding:.5rem; }
    .ok { background:#e7ffe7; color:#0a6; padding:.5rem; }
    .row-actions a, .row-actions form { display:inline-block; margin-right:.25rem; }
    .row-actions form { margin:0; }
  </style>
</head>
<body>

<h1>Contacts</h1>

<?php if (isset($_GET['created'])): ?>
  <div class="ok">Contact créé avec succès.</div>
<?php endif; ?>
<?php if (isset($_GET['updated'])): ?>
  <div class="ok">Contact mis à jour.</div>
<?php endif; ?>
<?php if (isset($_GET['deleted'])): ?>
  <div class="ok">Contact supprimé.</div>
<?php endif; ?>

<?php if ($errors): ?>
  <div class="errors">
    <ul><?php foreach ($errors as $err): ?><li><?= e($err) ?></li><?php endforeach; ?></ul>
  </div>
<?php endif; ?>

<h2>Ajouter un contact</h2>
<form method="post" action="index.php" autocomplete="off">
  <input type="hidden" name="action" value="create">
  <label>
    Nom<br>
    <input name="name" required>
  </label>
  <label>
    Email<br>
    <input name="email" type="email" required>
  </label>
  <button type="submit">Enregistrer</button>
</form>

<h2>Liste des contacts</h2>
<table>
  <thead>
    <tr><th>ID</th><th>Nom</th><th>Email</th><th>Créé le</th><th>Actions</th></tr>
  </thead>
  <tbody>
  <?php foreach ($contacts as $c): ?>
    <tr>
      <td><?= (int)$c['id'] ?></td>
      <td><?= e($c['name']) ?></td>
      <td><?= e($c['email']) ?></td>
      <td><?= e($c['created_at']) ?></td>
      <td class="row-actions">
        <a href="edit.php?id=<?= (int)$c['id'] ?>">Modifier</a>
        <form action="delete.php" method="post" onsubmit="return confirm('Supprimer ce contact ?');">
          <input type="hidden" name="id" value="<?= (int)$c['id'] ?>">
          <button type="submit">Supprimer</button>
        </form>
      </td>
    </tr>
  <?php endforeach; ?>
  </tbody>
</table>

</body>
</html>
```

**Sécurité Implémentée :**
1. **Requêtes préparées** : `prepare()/execute()` au lieu de concaténation
2. **Validation serveur** : `filter_var()` pour les emails
3. **Échappement HTML** : fonction `e()` contre XSS
4. **Pattern PRG** : Évite la double soumission

---

**Fichier : `edit.php` (Update)**
```php
<?php
/**
 * Page d'édition (Update)
 * - Affiche un formulaire prérempli
 * - Met à jour après validation
 */
require __DIR__ . '/db.php';

// Sécurité : validation de l'ID
$id = (int)($_GET['id'] ?? 0);
if ($id <= 0) {
    http_response_code(400);
    exit('ID invalide');
}

// Récupère le contact à éditer
$stmt = pdo()->prepare('SELECT * FROM contacts WHERE id = ?');
$stmt->execute([$id]);
$contact = $stmt->fetch();

if (!$contact) {
    http_response_code(404);
    exit('Contact introuvable');
}

$errors = [];

// UPDATE - Traitement de la modification
if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    $name  = trim((string)($_POST['name']  ?? ''));
    $email = trim((string)($_POST['email'] ?? ''));

    // Validation (identique à la création)
    if ($name === '') {
        $errors[] = "Le nom est obligatoire.";
    }
    if ($email === '' || !filter_var($email, FILTER_VALIDATE_EMAIL)) {
        $errors[] = "L'email est obligatoire et doit être valide.";
    }

    if (!$errors) {
        // Mise à jour sécurisée
        $upd = pdo()->prepare('UPDATE contacts SET name = ?, email = ? WHERE id = ?');
        $upd->execute([$name, $email, $id]);
        header('Location: index.php?updated=1');
        exit;
    }
}
?>
<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>Modifier un contact</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body { font-family:sans-serif; margin:2rem; }
    form { display:grid; gap:.5rem; max-width:420px; }
    .errors { background:#ffecec; color:#b00020; padding:.5rem; }
  </style>
</head>
<body>

<h1>Modifier le contact #<?= (int)$contact['id'] ?></h1>

<?php if ($errors): ?>
  <div class="errors">
    <ul><?php foreach ($errors as $err): ?><li><?= e($err) ?></li><?php endforeach; ?></ul>
  </div>
<?php endif; ?>

<form method="post" autocomplete="off">
  <label>
    Nom<br>
    <input name="name" value="<?= e($_POST['name'] ?? $contact['name']) ?>" required>
  </label>
  <label>
    Email<br>
    <input name="email" type="email" value="<?= e($_POST['email'] ?? $contact['email']) ?>" required>
  </label>
  <button type="submit">Enregistrer</button>
  <a href="index.php">Annuler</a>
</form>

</body>
</html>
```

---

**Fichier : `delete.php` (Delete)**
```php
<?php
/**
 * Suppression (Delete) en POST uniquement
 * IMPORTANT : On ne répond jamais en GET pour éviter les suppressions accidentelles
 */
require __DIR__ . '/db.php';

// Sécurité : uniquement en POST
if ($_SERVER['REQUEST_METHOD'] !== 'POST') {
    http_response_code(405);
    header('Allow: POST');
    exit('Méthode non autorisée');
}

$id = (int)($_POST['id'] ?? 0);
if ($id <= 0) {
    http_response_code(400);
    exit('ID invalide');
}

// DELETE sécurisé
$stmt = pdo()->prepare('DELETE FROM contacts WHERE id = ?');
$stmt->execute([$id]);

header('Location: index.php?deleted=1');
exit;
```

---

# Partie 2 : Introduction aux ORM

## 2.1 Qu'est-ce qu'un ORM ?

### Contexte : Comprendre l'abstraction objet-relationnel

**Concept Clé :** Un ORM (Object-Relational Mapping) fait le pont entre votre code objet et votre base de données relationnelle.

**Avantages des ORM :**
- **Productivité** : Moins de code SQL à écrire
- **Maintenabilité** : Code plus lisible et organisé
- **Portabilité** : Changer de SGBD plus facilement
- **Sécurité** : Protection automatique contre les injections

**Inconvénients :**
- **Courbe d'apprentissage** : Concepts supplémentaires à maîtriser
- **Performance** : Peut être moins efficace que du SQL optimisé
- **Complexité** : Abstraction parfois trop éloignée de la base

---

## 2.2 Doctrine ORM - Le Standard Professionnel

### Contexte : Découvrir l'ORM le plus utilisé dans l'écosystème PHP

**Concept Clé :** Doctrine suit le pattern Data Mapper : vos objets métier sont séparés de la persistance.

**Installation : `composer.json`**
```json
{
  "name": "demo/crud-doctrine",
  "type": "project",
  "require": {
    "php": "^8.1",
    "doctrine/orm": "^3.0",
    "doctrine/cache": "^2.2",
    "symfony/cache": "^7.0"
  },
  "autoload": {
    "psr-4": {
      "App\\": "src/"
    }
  }
}
```

**Configuration : `bootstrap.php`**
```php
<?php
/**
 * Bootstrap de Doctrine ORM (EntityManager)
 * - Configure le mappage via attributs PHP 8
 * - Active un cache simple via Filesystem
 * - Crée l'EntityManager à réutiliser partout
 */
use Doctrine\ORM\EntityManager;
use Doctrine\ORM\ORMSetup;
use Doctrine\DBAL\DriverManager;
use Symfony\Component\Cache\Adapter\FilesystemAdapter;

require __DIR__ . '/vendor/autoload.php';
require __DIR__ . '/config.php';

$paths = [__DIR__ . '/src/Entity'];     // Dossier des entités
$isDevMode = true;                      // Mode développement
$config = ORMSetup::createAttributeMetadataConfiguration($paths, $isDevMode);

// Configuration de la connexion
$connectionParams = [
    'dbname'   => DB_NAME,
    'user'     => DB_USER,
    'password' => DB_PASS,
    'host'     => DB_HOST,
    'driver'   => 'pdo_mysql',
    'charset'  => 'utf8mb4',
];

$connection = DriverManager::getConnection($connectionParams, $config);

/**
 * Fournit l'EntityManager (service principal de Doctrine)
 */
function entityManager(): EntityManager {
    static $em = null;
    if ($em === null) {
        global $connection, $config;
        $em = new EntityManager($connection, $config);
    }
    return $em;
}

/**
 * Échappement HTML pour l'affichage (anti-XSS)
 */
function e(string $s): string {
    return htmlspecialchars($s, ENT_QUOTES | ENT_SUBSTITUTE, 'UTF-8');
}
?>
```

---

## 2.3 Les Entités Doctrine

### Contexte : Définir vos objets métier qui seront persistés

**Concept Clé :** Une entité = une classe PHP qui représente une table en base.

**Fichier : `src/Entity/Contact.php`**
```php
<?php
namespace App\Entity;

use Doctrine\ORM\Mapping as ORM;

#[ORM\Entity]                       // Marque la classe comme entité Doctrine
#[ORM\Table(name: "contacts")]      // Table MySQL correspondante
class Contact
{
    #[ORM\Id]
    #[ORM\GeneratedValue]           // AUTO_INCREMENT
    #[ORM\Column(type: "integer", options: ["unsigned" => true])]
    private ?int $id = null;

    #[ORM\Column(type: "string", length: 120)]
    private string $name;

    #[ORM\Column(type: "string", length: 190)]
    private string $email;

    #[ORM\Column(type: "datetime_immutable")]
    private \DateTimeImmutable $createdAt;

    // CONSTRUCTEUR : initialise les propriétés obligatoires
    public function __construct(string $name, string $email)
    {
        $this->name = $name;
        $this->email = $email;
        $this->createdAt = new \DateTimeImmutable('now');
    }

    // --- GETTERS / SETTERS ---
    // Doctrine utilise la réflexion, mais les getters/setters sont une bonne pratique

    public function getId(): ?int { return $this->id; }

    public function getName(): string { return $this->name; }
    public function setName(string $name): self { 
        $this->name = $name; 
        return $this; // Fluent interface
    }

    public function getEmail(): string { return $this->email; }
    public function setEmail(string $email): self { 
        $this->email = $email; 
        return $this;
    }

    public function getCreatedAt(): \DateTimeImmutable { return $this->createdAt; }
}
```

**Points Importants :**
- **Attributs PHP 8** : `#[ORM\...]` pour le mapping
- **Typage strict** : Lever les erreurs rapidement
- **Immutabilité** : `DateTimeImmutable` pour les dates
- **Fluent interface** : `return $this` pour les setters

---

## 2.4 CRUD avec Doctrine

### Contexte : Réimplémenter les opérations CRUD avec l'approche objet

**Concept Clé :** Avec Doctrine, on manipule des objets, pas du SQL.

**Fichier : `public/index.php` (Create + Read avec Doctrine)**
```php
<?php
use App\Entity\Contact;

require __DIR__ . '/../bootstrap.php';

$em = entityManager();
$errors = [];

// CREATE avec Doctrine
if ($_SERVER['REQUEST_METHOD'] === 'POST' && ($_POST['action'] ?? '') === 'create') {
    $name  = trim((string)($_POST['name']  ?? ''));
    $email = trim((string)($_POST['email'] ?? ''));

    // Validation (identique)
    if ($name === '') {
        $errors[] = "Le nom est obligatoire.";
    }
    if ($email === '' || !filter_var($email, FILTER_VALIDATE_EMAIL)) {
        $errors[] = "L'email est obligatoire et doit être valide.";
    }

    if (!$errors) {
        // APPROCHE OBJET : on crée une instance et Doctrine gère la persistance
        $contact = new Contact($name, $email);
        $em->persist($contact); // "Prépare" l'INSERT
        $em->flush();           // Exécute en base
        
        header('Location: index.php?created=1');
        exit;
    }
}

// READ avec Doctrine Repository
$repo = $em->getRepository(Contact::class);
$contacts = $repo->findBy([], ['createdAt' => 'DESC']); // SELECT * ORDER BY created_at DESC
?>
<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>Contacts - CRUD Doctrine ORM</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body { font-family:sans-serif; margin:2rem; }
    table { border-collapse:collapse; width:100%; margin-top:1rem; }
    th, td { border:1px solid #ddd; padding:.5rem; vertical-align: top; }
    form { display:grid; gap:.5rem; max-width:420px; margin-top:1rem; }
    .errors { background:#ffecec; color:#b00020; padding:.5rem; }
    .ok { background:#e7ffe7; color:#0a6; padding:.5rem; }
    .row-actions a, .row-actions form { display:inline-block; margin-right:.25rem; }
    .row-actions form { margin:0; }
  </style>
</head>
<body>

<h1>Contacts (Doctrine ORM)</h1>

<?php if (isset($_GET['created'])): ?>
  <div class="ok">Contact créé avec succès.</div>
<?php endif; ?>
<?php if (isset($_GET['updated'])): ?>
  <div class="ok">Contact mis à jour.</div>
<?php endif; ?>
<?php if (isset($_GET['deleted'])): ?>
  <div class="ok">Contact supprimé.</div>
<?php endif; ?>

<?php if ($errors): ?>
  <div class="errors">
    <ul><?php foreach ($errors as $err): ?><li><?= e($err) ?></li><?php endforeach; ?></ul>
  </div>
<?php endif; ?>

<h2>Ajouter un contact</h2>
<form method="post" action="index.php" autocomplete="off">
  <input type="hidden" name="action" value="create">
  <label>
    Nom<br>
    <input name="name" required>
  </label>
  <label>
    Email<br>
    <input name="email" type="email" required>
  </label>
  <button type="submit">Enregistrer</button>
</form>

<h2>Liste des contacts</h2>
<table>
  <thead>
    <tr><th>ID</th><th>Nom</th><th>Email</th><th>Créé le</th><th>Actions</th></tr>
  </thead>
  <tbody>
  <?php foreach ($contacts as $c): ?>
    <tr>
      <td><?= (int)$c->getId() ?></td>
      <td><?= e($c->getName()) ?></td>
      <td><?= e($c->getEmail()) ?></td>
      <td><?= e($c->getCreatedAt()->format('Y-m-d H:i:s')) ?></td>
      <td class="row-actions">
        <a href="edit.php?id=<?= (int)$c->getId() ?>">Modifier</a>
        <form action="delete.php" method="post" onsubmit="return confirm('Supprimer ce contact ?');">
          <input type="hidden" name="id" value="<?= (int)$c->getId() ?>">
          <button type="submit">Supprimer</button>
        </form>
      </td>
    </tr>
  <?php endforeach; ?>
  </tbody>
</table>

</body>
</html>
```

**Comparaison PDO vs Doctrine :**
| Opération | PDO | Doctrine |
|-----------|-----|----------|
| **CREATE** | `prepare()->execute()` | `persist() + flush()` |
| **READ** | `query()->fetchAll()` | `findBy() / find()` |
| **UPDATE** | `prepare()->execute()` | setters + `flush()` |
| **DELETE** | `prepare()->execute()` | `remove() + flush()` |

---

**Fichier : `public/edit.php` (Update avec Doctrine)**
```php
<?php
use App\Entity\Contact;

require __DIR__ . '/../bootstrap.php';

$em = entityManager();
$id = (int)($_GET['id'] ?? 0);
if ($id <= 0) { http_response_code(400); exit('ID invalide'); }

// Chargement par ID
$contact = $em->find(Contact::class, $id);
if (!$contact) { http_response_code(404); exit('Contact introuvable'); }

$errors = [];

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    $name  = trim((string)($_POST['name']  ?? ''));
    $email = trim((string)($_POST['email'] ?? ''));

    // Validation
    if ($name === '') {
        $errors[] = "Le nom est obligatoire.";
    }
    if ($email === '' || !filter_var($email, FILTER_VALIDATE_EMAIL)) {
        $errors[] = "L'email est obligatoire et doit être valide.";
    }

    if (!$errors) {
        // UPDATE : modification directe de l'objet + flush()
        $contact->setName($name)->setEmail($email);
        $em->flush(); // UPDATE automatique (Doctrine suit les changements)
        
        header('Location: index.php?updated=1');
        exit;
    }
}
?>
<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>Modifier un contact (Doctrine)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body { font-family:sans-serif; margin:2rem; }
    form { display:grid; gap:.5rem; max-width:420px; }
    .errors { background:#ffecec; color:#b00020; padding:.5rem; }
  </style>
</head>
<body>

<h1>Modifier le contact #<?= (int)$contact->getId() ?></h1>

<?php if ($errors): ?>
  <div class="errors">
    <ul><?php foreach ($errors as $err): ?><li><?= e($err) ?></li><?php endforeach; ?></ul>
  </div>
<?php endif; ?>

<form method="post" autocomplete="off">
  <label>
    Nom<br>
    <input name="name" value="<?= e($_POST['name'] ?? $contact->getName()) ?>" required>
  </label>
  <label>
    Email<br>
    <input name="email" type="email" value="<?= e($_POST['email'] ?? $contact->getEmail()) ?>" required>
  </label>
  <button type="submit">Enregistrer</button>
  <a href="index.php">Annuler</a>
</form>

</body>
</html>
```

**Magie de Doctrine :** Pas besoin de dire quoi UPDATE - Doctrine détecte les changements automatiquement !

---

**Fichier : `public/delete.php` (Delete avec Doctrine)**
```php
<?php
use App\Entity\Contact;

require __DIR__ . '/../bootstrap.php';

if ($_SERVER['REQUEST_METHOD'] !== 'POST') {
    http_response_code(405);
    header('Allow: POST');
    exit('Méthode non autorisée');
}

$em = entityManager();
$id = (int)($_POST['id'] ?? 0);
if ($id <= 0) { http_response_code(400); exit('ID invalide'); }

$contact = $em->find(Contact::class, $id);
if ($contact) {
    $em->remove($contact); // Planifie le DELETE
    $em->flush();          // Exécute le DELETE
}

header('Location: index.php?deleted=1');
exit;
```

---

## 2.5 Outils et Migration

### Contexte : Gérer l'évolution du schéma de base

**Concept Clé :** Doctrine peut générer automatiquement le schéma à partir de vos entités.

**Fichier : `tools/schema_create.php`**
```php
<?php
/**
 * (Ré)crée le schéma DB à partir des métadonnées Doctrine
 * À utiliser en démo/atelier (en prod, préférer Doctrine Migrations)
 */
use Doctrine\ORM\Tools\SchemaTool;

require __DIR__ . '/../bootstrap.php';

$em = entityManager();
$metadata = $em->getMetadataFactory()->getAllMetadata();

if (empty($metadata)) {
    echo "Aucune entité détectée.\n";
    exit(1);
}

$tool = new SchemaTool($em);
$tool->dropDatabase();
$tool->createSchema($metadata);

echo "Schéma créé avec succès.\n";
```

**Utilisation :**
```bash
php tools/schema_create.php
```

---

# Partie 3 : Comparaison et Choix

## 3.1 PDO vs ORM : Quand Choisir Quoi ?

### Tableau Comparatif

| Critère | PDO | Doctrine ORM |
|---------|-----|--------------|
| **Courbe d'apprentissage** | Facile | Modérée |
| **Performance** | Excellente | Bonne (avec optimisation) |
| **Productivité** | Moyenne | Excellente |
| **Sécurité** | Excellente (avec preps) | Excellente |
| **Maintenabilité** | Variable | Excellente |
| **Portabilité** | Limitée | Excellente |

### Guide de Choix

**Choisir PDO quand :**
- Petit projet simple
- Besoin de performance maximale
- Équipe débutante en PHP
- Contrôle total sur le SQL

**Choisir Doctrine quand :**
- Projet de moyenne à grande taille
- Équipe expérimentée
- Besoin de maintenabilité
- Modèle métier complexe
- Évolutivité importante

---

## 3.2 Bonnes Pratiques Universelles

### Sécurité
1. **Toujours utiliser les requêtes préparées** (PDO ou ORM)
2. **Valider les entrées utilisateur** côté serveur
3. **Échapper les sorties** avec `htmlspecialchars()`
4. **Utiliser HTTPS** en production

### Performance
1. **Fermer les connexions** (PDO) ou **clear()** (Doctrine) si nécessaire
2. **Utiliser le lazy loading** judicieusement avec Doctrine
3. **Indexer** les colonnes fréquemment interrogées
4. **Limiter** les données retournées avec `SELECT`

### Maintenance
1. **Documenter** votre modèle de données
2. **Versionner** les migrations de base
3. **Tester** vos requêtes critiques
4. **Monitorer** les performances des requêtes

---

# Partie 4 : Mise en Pratique

## 4.1 Exercices Progressifs

### Exercice 1 : Migration PDO → Doctrine
Reprenez un projet PDO existant et migrez-le vers Doctrine

### Exercice 2 : Relations avec Doctrine
Ajoutez une entité `Company` et créez une relation `ManyToOne` avec `Contact`

### Exercice 3 : Recherche Avancée
Implémentez un système de recherche avec pagination en utilisant le QueryBuilder de Doctrine

### Exercice 4 : Tests Unitaires
Créez des tests pour votre repository Doctrine

---

## Conclusion

**Félicitations !** Vous maîtrisez maintenant :

- **PDO et les requêtes préparées** pour un contrôle total
- **Doctrine ORM** pour une productivité maximale  
- **Les bonnes pratiques de sécurité** essentielles
- **Les critères de choix** entre les différentes approches

**Prochaines étapes :**
- Explorer le **QueryBuilder** de Doctrine
- Découvrir les **relations** (OneToMany, ManyToMany)
- Maîtriser les **migrations** de base de données
- Implémenter les **tests** avec la base de données

**Rappel :** La meilleure approche est celle qui correspond à votre projet et à votre équipe. Maîtrisez les deux pour être un développeur PHP complet !